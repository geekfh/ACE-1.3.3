/*!
 * FullCalendar v2.2.3
 * Docs & License: http://arshaw.com/fullcalendar/
 * (c) 2013 Adam Shaw
 */
!function(a){"function"==typeof define&&define.amd?define(["jquery","moment"],a):a(jQuery,moment)}(function(a,b){function c(a,b){return b.longDateFormat("LT").replace(":mm","(:mm)").replace(/(\Wmm)$/,"($1)").replace(/\s*a$/i,"t")}function d(a,b){var c=b.longDateFormat("L");// for the format like "MM/DD/YYYY"
// strip the year off the edge, as well as other misc non-whitespace chars
return c=c.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g,""),a.isRTL?c+=" ddd":c="ddd "+c,c}
// function for adding/overriding defaults
function e(a){f(Ga,a)}
// Recursively combines option hash-objects.
// Better than `$.extend(true, ...)` because arrays are not traversed/copied.
//
// called like:
//     mergeOptions(target, obj1, obj2, ...)
//
function f(b){function c(c,d){a.isPlainObject(d)&&a.isPlainObject(b[c])&&!g(c)?
// merge into a new object to avoid destruction
b[c]=f({},b[c],d):void 0!==d&&(// only use values that are set and not undefined
b[c]=d)}for(var d=1;d<arguments.length;d++)a.each(arguments[d],c);return b}
// overcome sucky view-option-hash and option-merging behavior messing with options it shouldn't
function g(a){
// Any option that ends in "Time" or "Duration" is probably a Duration,
// and these will commonly be specified as plain objects, which we don't want to mess up.
return/(Time|Duration)$/.test(a)}function h(c,d){
// Language-data Internals
// -----------------------------------------------------------------------------------
// Apply overrides to the current language's data
// Returns moment's internal locale data. If doesn't exist, returns English.
// Works with moment-pre-2.8
function e(a){var c=b.localeData||b.langData;return c.call(b,a)||c.call(b,"en")}function g(a){ca?l()&&(
// mainly for the public API
p(),n(a)):h()}function h(){da=Z.theme?"ui":"fc",c.addClass("fc"),Z.isRTL?c.addClass("fc-rtl"):c.addClass("fc-ltr"),Z.theme?c.addClass("ui-widget"):c.addClass("fc-unthemed"),ca=a("<div class='fc-view-container'/>").prependTo(c),aa=new i(X,Z),ba=aa.render(),ba&&c.prepend(ba),m(Z.defaultView),Z.handleWindowResize&&(ga=J(r,Z.windowResizeDelay),a(window).resize(ga))}function k(){ea&&ea.destroy(),aa.destroy(),ca.remove(),c.removeClass("fc fc-ltr fc-rtl fc-unthemed ui-widget"),a(window).unbind("resize",ga)}function l(){return c.is(":visible")}
// View Rendering
// -----------------------------------------------------------------------------------
function m(a){n(0,a)}
// Renders a view because of a date change, view-type change, or for the first time
function n(b,c){la++,
// if viewName is changing, destroy the old view
ea&&c&&ea.name!==c&&(aa.deactivateButton(ea.name),Q(),// prevent a scroll jump when view element is removed
ea.start&&// rendered before?
ea.destroy(),ea.el.remove(),ea=null),
// if viewName changed, or the view was never created, create a fresh view
!ea&&c&&(ea=new Ka[c](X),ea.el=a("<div class='fc-view fc-"+c+"-view' />").appendTo(ca),aa.activateButton(c)),ea&&(
// let the view determine what the delta means
b&&(ha=ea.incrementDate(ha,b)),
// render or rerender the view
ea.start&&!b&&ha.isWithin(ea.intervalStart,ea.intervalEnd)||l()&&(Q(),ea.start&&// rendered before?
ea.destroy(),ea.render(ha),R(),
// need to do this after View::render, so dates are calculated
z(),A(),v())),R(),// undo any lone freezeContentHeight calls
la--}function o(a){// isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()
return l()?(a&&q(),la++,ea.updateSize(!0),la--,!0):void 0}function p(){l()&&q()}function q(){// assumes elementVisible
fa="number"==typeof Z.contentHeight?Z.contentHeight:"number"==typeof Z.height?Z.height-(ba?ba.outerHeight(!0):0):Math.round(ca.width()/Math.max(Z.aspectRatio,.5))}function r(a){!la&&a.target===window&&ea.start&&o(!0)&&ea.trigger("windowResize",ka)}/* Event Fetching/Rendering
	-----------------------------------------------------------------------------*/
// TODO: going forward, most of this stuff should be directly handled by the view
function s(){// can be called as an API method
u(),// so that events are cleared before user starts waiting for AJAX
w()}function t(){// destroys old events if previously rendered
l()&&(Q(),ea.destroyEvents(),// no performance cost if never rendered
ea.renderEvents(ma),R())}function u(){Q(),ea.destroyEvents(),R()}function v(){!Z.lazyFetching||ia(ea.start,ea.end)?w():t()}function w(){ja(ea.start,ea.end)}
// called when event data arrives
function x(a){ma=a,t()}
// called when a single event's data has been changed
function y(){t()}/* Header Updating
	-----------------------------------------------------------------------------*/
function z(){aa.updateTitle(ea.title)}function A(){var a=X.getNow();a.isWithin(ea.intervalStart,ea.intervalEnd)?aa.disableButton("today"):aa.enableButton("today")}/* Selection
	-----------------------------------------------------------------------------*/
function B(a,b){a=X.moment(a),b=b?X.moment(b):a.hasTime()?a.clone().add(X.defaultTimedEventDuration):a.clone().add(X.defaultAllDayEventDuration),ea.select(a,b)}function D(){// safe to be called before renderView
ea&&ea.unselect()}/* Date
	-----------------------------------------------------------------------------*/
function E(){n(-1)}function F(){n(1)}function G(){ha.add(-1,"years"),n()}function I(){ha.add(1,"years"),n()}function K(){ha=X.getNow(),n()}function L(a){ha=X.moment(a),n()}function M(a){ha.add(b.duration(a)),n()}
// Forces navigation to a view for the given date.
// `viewName` can be a specific view name or a generic one like "week" or "day".
function N(a,b){var c,d;b&&void 0!==Ka[b]||(b=b||"day",c=aa.getViewsWithButtons().join(" "),d=c.match(new RegExp("\\w+"+H(b))),d||(d=c.match(/\w+Day/)),b=d?d[0]:"agendaDay"),ha=a,m(b)}function O(){return ha.clone()}/* Height "Freezing"
	-----------------------------------------------------------------------------*/
function Q(){ca.css({width:"100%",height:ca.height(),overflow:"hidden"})}function R(){ca.css({width:"",height:"",overflow:""})}/* Misc
	-----------------------------------------------------------------------------*/
function T(){return X}function U(){return ea}function V(a,b){return void 0===b?Z[a]:void(("height"==a||"contentHeight"==a||"aspectRatio"==a)&&(Z[a]=b,o(!0)))}function W(a,b){return Z[a]?Z[a].apply(b||ka,Array.prototype.slice.call(arguments,2)):void 0}var X=this;
// Build options object
// -----------------------------------------------------------------------------------
// Precedence (lowest to highest): defaults, rtlDefaults, langOptions, instanceOptions
d=d||{};var Y,Z=f({},Ga,d);
// determine language options
Y=Z.lang in Ha?Ha[Z.lang]:Ha[Ga.lang],Y&&(Z=f({},Ga,Y,d)),Z.isRTL&&(Z=f({},Ga,Ia,Y||{},d)),X.options=Z,X.render=g,X.destroy=k,X.refetchEvents=s,X.reportEvents=x,X.reportEventChange=y,X.rerenderEvents=t,X.changeView=m,X.select=B,X.unselect=D,X.prev=E,X.next=F,X.prevYear=G,X.nextYear=I,X.today=K,X.gotoDate=L,X.incrementDate=M,X.zoomTo=N,X.getDate=O,X.getCalendar=T,X.getView=U,X.option=V,X.trigger=W;var $=C(e(Z.lang));if(// make a cheap copy
Z.monthNames&&($._months=Z.monthNames),Z.monthNamesShort&&($._monthsShort=Z.monthNamesShort),Z.dayNames&&($._weekdays=Z.dayNames),Z.dayNamesShort&&($._weekdaysShort=Z.dayNamesShort),null!=Z.firstDay){var _=C($._week);// _week: { dow: # }
_.dow=Z.firstDay,$._week=_}
// Calendar-specific Date Utilities
// -----------------------------------------------------------------------------------
X.defaultAllDayEventDuration=b.duration(Z.defaultAllDayEventDuration),X.defaultTimedEventDuration=b.duration(Z.defaultTimedEventDuration),
// Builds a moment using the settings of the current calendar: timezone and language.
// Accepts anything the vanilla moment() constructor accepts.
X.moment=function(){var a;
// Force the moment to be local, because fc.moment doesn't guarantee it.
// don't give ambiguously-timed moments a local zone
// moment 2.8 and above
// pre-moment-2.8
return"local"===Z.timezone?(a=Ja.moment.apply(null,arguments),a.hasTime()&&a.local()):a="UTC"===Z.timezone?Ja.moment.utc.apply(null,arguments):Ja.moment.parseZone.apply(null,arguments),"_locale"in a?a._locale=$:a._lang=$,a},
// Returns a boolean about whether or not the calendar knows how to calculate
// the timezone offset of arbitrary dates in the current timezone.
X.getIsAmbigTimezone=function(){return"local"!==Z.timezone&&"UTC"!==Z.timezone},
// Returns a copy of the given date in the current timezone of it is ambiguously zoned.
// This will also give the date an unambiguous time.
X.rezoneDate=function(a){return X.moment(a.toArray())},
// Returns a moment for the current date, as defined by the client's computer,
// or overridden by the `now` option.
X.getNow=function(){var a=Z.now;return"function"==typeof a&&(a=a()),X.moment(a)},
// Calculates the week number for a moment according to the calendar's
// `weekNumberCalculation` setting.
X.calculateWeekNumber=function(a){var b=Z.weekNumberCalculation;return"function"==typeof b?b(a):"local"===b?a.week():"ISO"===b.toUpperCase()?a.isoWeek():void 0},
// Get an event's normalized end date. If not present, calculate it from the defaults.
X.getEventEnd=function(a){return a.end?a.end.clone():X.getDefaultEventEnd(a.allDay,a.start)},
// Given an event's allDay status and start date, return swhat its fallback end date should be.
X.getDefaultEventEnd=function(a,b){// TODO: rename to computeDefaultEventEnd
var c=b.clone();return a?c.stripTime().add(X.defaultAllDayEventDuration):c.add(X.defaultTimedEventDuration),X.getIsAmbigTimezone()&&c.stripZone(),c},
// Date-formatting Utilities
// -----------------------------------------------------------------------------------
// Like the vanilla formatRange, but with calendar-specific settings applied.
X.formatRange=function(a,b,c){
// a function that returns a formatStr // TODO: in future, precompute this
return"function"==typeof c&&(c=c.call(X,Z,$)),S(a,b,c,null,Z.isRTL)},
// Like the vanilla formatDate, but with calendar-specific settings applied.
X.formatDate=function(a,b){
// a function that returns a formatStr // TODO: in future, precompute this
return"function"==typeof b&&(b=b.call(X,Z,$)),P(a,b)},
// Imports
// -----------------------------------------------------------------------------------
j.call(X,Z);var aa,ba,ca,da,ea,fa,ga,ha,ia=X.isFetchNeeded,ja=X.fetchEvents,ka=c[0],la=0,ma=[];
// Main Rendering
// -----------------------------------------------------------------------------------
ha=null!=Z.defaultDate?X.moment(Z.defaultDate):X.getNow(),X.getSuggestedViewHeight=function(){return void 0===fa&&p(),fa},X.isHeightAuto=function(){return"auto"===Z.contentHeight||"auto"===Z.height}}/* Top toolbar area with buttons and title
----------------------------------------------------------------------------------------------------------------------*/
// TODO: rename all header-related things to "toolbar"
function i(b,c){function d(){var b=c.header;return n=c.theme?"ui":"fc",b?o=a("<div class='fc-toolbar'/>").append(f("left")).append(f("right")).append(f("center")).append('<div class="fc-clear"/>'):void 0}function e(){o.remove()}function f(d){var e=a('<div class="fc-'+d+'"/>'),f=c.header[d];return f&&a.each(f.split(" "),function(d){var f,g=a(),h=!0;a.each(this.split(","),function(d,e){var f,i,j,k,l,m,o,q;"title"==e?(g=g.add(a("<h2>&nbsp;</h2>")),h=!1):(b[e]?// a calendar method
f=function(){b[e]()}:Ka[e]&&(f=function(){b.changeView(e)},p.push(e)),f&&(i=y(c.themeButtonIcons,e),j=y(c.buttonIcons,e),k=y(c.defaultButtonText,e),l=y(c.buttonText,e),m=l?F(l):i&&c.theme?"<span class='ui-icon ui-icon-"+i+"'></span>":j&&!c.theme?"<span class='fc-icon fc-icon-"+j+"'></span>":F(k||e),o=["fc-"+e+"-button",n+"-button",n+"-state-default"],q=a('<button type="button" class="'+o.join(" ")+'">'+m+"</button>").click(function(){q.hasClass(n+"-state-disabled")||(f(),(q.hasClass(n+"-state-active")||q.hasClass(n+"-state-disabled"))&&q.removeClass(n+"-state-hover"))}).mousedown(function(){q.not("."+n+"-state-active").not("."+n+"-state-disabled").addClass(n+"-state-down")}).mouseup(function(){q.removeClass(n+"-state-down")}).hover(function(){q.not("."+n+"-state-active").not("."+n+"-state-disabled").addClass(n+"-state-hover")},function(){q.removeClass(n+"-state-hover").removeClass(n+"-state-down")}),g=g.add(q)))}),h&&g.first().addClass(n+"-corner-left").end().last().addClass(n+"-corner-right").end(),g.length>1?(f=a("<div/>"),h&&f.addClass("fc-button-group"),f.append(g),e.append(f)):e.append(g)}),e}function g(a){o.find("h2").text(a)}function h(a){o.find(".fc-"+a+"-button").addClass(n+"-state-active")}function i(a){o.find(".fc-"+a+"-button").removeClass(n+"-state-active")}function j(a){o.find(".fc-"+a+"-button").attr("disabled","disabled").addClass(n+"-state-disabled")}function k(a){o.find(".fc-"+a+"-button").removeAttr("disabled").removeClass(n+"-state-disabled")}function l(){return p}var m=this;
// exports
m.render=d,m.destroy=e,m.updateTitle=g,m.activateButton=h,m.deactivateButton=i,m.disableButton=j,m.enableButton=k,m.getViewsWithButtons=l;
// locals
var n,o=a(),p=[]}function j(c){/* Fetching
	-----------------------------------------------------------------------------*/
function d(a,b){// nothing has been fetched yet?
// or, a part of the new range is outside of the old range? (after normalizing)
return!M||a.clone().stripZone()<M.clone().stripZone()||b.clone().stripZone()>N.clone().stripZone()}function e(a,b){M=a,N=b,X=[];var c=++U,d=T.length;V=d;for(var e=0;d>e;e++)f(T[e],c)}function f(b,c){g(b,function(d){var e,f,g,h=a.isArray(b.events);if(c==U){if(d)for(e=0;e<d.length;e++)f=d[e],g=h?f:u(f,b),g&&X.push.apply(X,w(g));V--,V||Q(X)}})}function g(b,d){var e,f,h=Ja.sourceFetchers;for(e=0;e<h.length;e++){if(f=h[e].call(L,// this, the Calendar object
b,M.clone(),N.clone(),c.timezone,d),f===!0)
// the fetcher is in charge. made its own async request
return;if("object"==typeof f)
// the fetcher returned a new source. process it
return void g(f,d)}var i=b.events;if(i)a.isFunction(i)?(s(),i.call(L,// this, the Calendar object
M.clone(),N.clone(),c.timezone,function(a){d(a),t()})):a.isArray(i)?d(i):d();else{var j=b.url;if(j){var k,l=b.success,m=b.error,n=b.complete;k=a.isFunction(b.data)?b.data():b.data;
// use a copy of the custom data so we can modify the parameters
// and not affect the passed-in object.
var o=a.extend({},k||{}),p=E(b.startParam,c.startParam),q=E(b.endParam,c.endParam),r=E(b.timezoneParam,c.timezoneParam);p&&(o[p]=M.format()),q&&(o[q]=N.format()),c.timezone&&"local"!=c.timezone&&(o[r]=c.timezone),s(),a.ajax(a.extend({},La,b,{data:o,success:function(b){b=b||[];var c=D(l,this,arguments);a.isArray(c)&&(b=c),d(b)},error:function(){D(m,this,arguments),d()},complete:function(){D(n,this,arguments),t()}}))}else d()}}/* Sources
	-----------------------------------------------------------------------------*/
function h(a){var b=i(a);b&&(T.push(b),V++,f(b,U))}function i(b){// will return undefined if invalid source
var c,d,e=Ja.sourceNormalizers;if(a.isFunction(b)||a.isArray(b)?c={events:b}:"string"==typeof b?c={url:b}:"object"==typeof b&&(c=a.extend({},b)),c){for(
// TODO: repeat code, same code for event classNames
c.className?"string"==typeof c.className&&(c.className=c.className.split(/\s+/)):c.className=[],
// for array sources, we convert to standard Event Objects up front
a.isArray(c.events)&&(c.origArray=c.events,// for removeEventSource
c.events=a.map(c.events,function(a){return u(a,c)})),d=0;d<e.length;d++)e[d].call(L,c);return c}}function j(b){T=a.grep(T,function(a){return!l(a,b)}),X=a.grep(X,function(a){return!l(a.source,b)}),Q(X)}function l(a,b){return a&&b&&m(a)==m(b)}function m(a){// a normalized event source?
// get the primitive
return("object"==typeof a?a.origArray||a.googleCalendarId||a.url||a.events:null)||a}/* Manipulation
	-----------------------------------------------------------------------------*/
function n(a){a.start=L.moment(a.start),a.end&&(a.end=L.moment(a.end)),x(a),o(a),Q(X)}function o(a){var b,c,d,e;for(b=0;b<X.length;b++)if(c=X[b],c._id==a._id&&c!==a)for(d=0;d<Y.length;d++)e=Y[d],void 0!==a[e]&&(c[e]=a[e])}
// returns the expanded events that were created
function p(a,b){var c,d,e,f=u(a);if(f){for(c=w(f),d=0;d<c.length;d++)e=c[d],e.source||(b&&(S.events.push(e),e.source=S),X.push(e));return Q(X),c}return[]}function q(b){var c,d;// inverse=true
// Remove events from array sources.
// This works because they have been converted to official Event Objects up front.
// (and as a result, event._id has been calculated).
for(null==b?// null or undefined. remove all events
b=function(){return!0}:a.isFunction(b)||(c=b+"",b=function(a){return a._id==c}),X=a.grep(X,b,!0),d=0;d<T.length;d++)a.isArray(T[d].events)&&(T[d].events=a.grep(T[d].events,b,!0));Q(X)}function r(b){// not null, not undefined. an event ID
return a.isFunction(b)?a.grep(X,b):null!=b?(b+="",a.grep(X,function(a){return a._id==b})):X}/* Loading State
	-----------------------------------------------------------------------------*/
function s(){W++||O("loading",null,!0,P())}function t(){--W||O("loading",null,!1,P())}/* Event Normalization
	-----------------------------------------------------------------------------*/
// Given a raw object with key/value properties, returns an "abstract" Event object.
// An "abstract" event is an event that, if recurring, will not have been expanded yet.
// Will return `false` when input is invalid.
// `source` is optional
function u(d,e){var f,g,h,i,j={};if(c.eventDataTransform&&(d=c.eventDataTransform(d)),e&&e.eventDataTransform&&(d=e.eventDataTransform(d)),
// Copy all properties over to the resulting object.
// The special-case properties will be copied over afterwards.
a.extend(j,d),e&&(j.source=e),j._id=d._id||(void 0===d.id?"_fc"+Ma++:d.id+""),d.className?"string"==typeof d.className?j.className=d.className.split(/\s+/):j.className=d.className:j.className=[],f=d.start||d.date,g=d.end,B(f)&&(f=b.duration(f)),B(g)&&(g=b.duration(g)),d.dow||b.isDuration(f)||b.isDuration(g))
// the event is "abstract" (recurring) so don't calculate exact start/end dates just yet
j.start=f?b.duration(f):null,// will be a Duration or null
j.end=g?b.duration(g):null,// will be a Duration or null
j._recurring=!0;else{if(f&&(f=L.moment(f),!f.isValid()))return!1;g&&(g=L.moment(g),g.isValid()||(g=null)),h=d.allDay,void 0===h&&(i=E(e?e.allDayDefault:void 0,c.allDayDefault),h=void 0!==i?i:!(f.hasTime()||g&&g.hasTime())),v(f,g,h,j)}return j}
// Normalizes and assigns the given dates to the given partially-formed event object.
// Requires an explicit `allDay` boolean parameter.
// NOTE: mutates the given start/end moments. does not make an internal copy
function v(a,b,d,e){
// normalize the date based on allDay
d?(
// neither date should have a time
a.hasTime()&&a.stripTime(),b&&b.hasTime()&&b.stripTime()):(
// force a time/zone up the dates
a.hasTime()||(a=L.rezoneDate(a)),b&&!b.hasTime()&&(b=L.rezoneDate(b))),b&&a>=b&&(// end is exclusive. must be after start
b=null),e.allDay=d,e.start=a,e.end=b||null,// ensure null if falsy
c.forceEventDuration&&!e.end&&(e.end=R(e)),k(e)}
// If the given event is a recurring event, break it down into an array of individual instances.
// If not a recurring event, return an array with the single original event.
// If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.
// HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).
function w(b,c,d){var e,f,g,h,i,j,k,l,m,n=[];if(c=c||M,d=d||N,b)if(b._recurring){
// make a boolean hash as to whether the event occurs on each day-of-week
if(f=b.dow)for(e={},g=0;g<f.length;g++)e[f[g]]=!0;// holds the date of the current day
for(
// iterate through every day in the current range
h=c.clone().stripTime();h.isBefore(d);)(!e||e[h.day()])&&(i=b.start,j=b.end,k=h.clone(),l=null,i&&(k=k.time(i)),j&&(l=h.clone().time(j)),m=a.extend({},b),v(k,l,!i&&!j,m),n.push(m)),h.add(1,"days")}else n.push(b);return n}/* Event Modification Math
	-----------------------------------------------------------------------------------------*/
// Modify the date(s) of an event and make this change propagate to all other events with
// the same ID (related repeating events).
//
// If `newStart`/`newEnd` are not specified, the "new" dates are assumed to be `event.start` and `event.end`.
// The "old" dates to be compare against are always `event._start` and `event._end` (set by EventManager).
//
// Returns an object with delta information and a function to undo all operations.
//
function x(a,b,c){var d,e,f,g,h=a._allDay,i=a._start,j=a._end,k=!1;
// if no new dates were passed in, compare against the event's existing dates
// NOTE: throughout this function, the initial values of `newStart` and `newEnd` are
// preserved. These values may be undefined.
// detect new allDay
// if value has changed, use it
// normalize the new dates based on allDay
// compute dateDelta
// if allDay has changed, always throw away the end
// new duration
// subtract old duration
// get events with this ID
return b||c||(b=a.start,c=a.end),d=a.allDay!=h?a.allDay:!(b||c).hasTime(),d&&(b&&(b=b.clone().stripTime()),c&&(c=c.clone().stripTime())),b&&(e=d?z(b,i.clone().stripTime()):z(b,i)),d!=h?k=!0:c&&(f=z(c||L.getDefaultEventEnd(d,b||i),b||i).subtract(z(j||L.getDefaultEventEnd(h,i),i))),g=y(r(a._id),k,d,e,f),{dateDelta:e,durationDelta:f,undo:g}}
// Modifies an array of events in the following ways (operations are in order):
// - clear the event's `end`
// - convert the event to allDay
// - add `dateDelta` to the start and end
// - add `durationDelta` to the event's duration
//
// Returns a function that can be called to undo all the operations.
//
function y(b,d,e,f,g){var h=L.getIsAmbigTimezone(),i=[];return a.each(b,function(a,b){var j=b._allDay,l=b._start,m=b._end,n=null!=e?e:j,o=l.clone(),p=!d&&m?m.clone():null;
// NOTE: this function is responsible for transforming `newStart` and `newEnd`,
// which were initialized to the OLD values first. `newEnd` may be null.
// normlize newStart/newEnd to be consistent with newAllDay
n?(o.stripTime(),p&&p.stripTime()):(o.hasTime()||(o=L.rezoneDate(o)),p&&!p.hasTime()&&(p=L.rezoneDate(p))),
// ensure we have an end date if necessary
p||!c.forceEventDuration&&!+g||(p=L.getDefaultEventEnd(n,o)),
// translate the dates
o.add(f),p&&p.add(f).add(g),
// if the dates have changed, and we know it is impossible to recompute the
// timezone offsets, strip the zone.
h&&(+f||+g)&&(o.stripZone(),p&&p.stripZone()),b.allDay=n,b.start=o,b.end=p,k(b),i.push(function(){b.allDay=j,b.start=l,b.end=m,k(b)})}),function(){for(var a=0;a<i.length;a++)i[a]()}}
// Returns an array of events as to when the business hours occur in the given view.
// Abuse of our event system :(
function A(){var b,d=c.businessHours,e={className:"fc-nonbusiness",start:"09:00",end:"17:00",dow:[1,2,3,4,5],// monday - friday
rendering:"inverse-background"},f=L.getView();
// option value is an object that can override the default business hours
return d&&(b="object"==typeof d?a.extend({},e,d):e),b?w(u(b),f.start,f.end):[]}function C(a,b,d){var e=a.source||{},f=E(a.constraint,e.constraint,c.eventConstraint),g=E(a.overlap,e.overlap,c.eventOverlap);return H(b,d,f,g,a)}function F(a,b){return H(a,b,c.selectConstraint,c.selectOverlap)}function G(a,b,c){// eventInput is optional associated event data
var d;return c&&(d=w(u(c))[0])?C(d,a,b):F(a,b)}
// Returns true if the given range (caused by an event drop/resize or a selection) is allowed to exist
// according to the constraint/overlap settings.
// `event` is not required if checking a selection.
function H(a,b,c,d,e){var f,g,h,i,j;
// the range must be fully contained by at least one of produced constraint events
if(a=a.clone().stripZone(),b=b.clone().stripZone(),null!=c){for(f=I(c),g=!1,h=0;h<f.length;h++)if(J(f[h],a,b)){g=!0;break}if(!g)return!1}for(h=0;h<X.length;h++)
// don't compare the event to itself or other related [repeating] events
if(i=X[h],(!e||e._id!==i._id)&&K(i,a,b)){
// evaluate overlap for the given range and short-circuit if necessary
if(d===!1)return!1;if("function"==typeof d&&!d(i,e))return!1;
// if we are computing if the given range is allowable for an event, consider the other event's
// EventObject-specific or Source-specific `overlap` property
if(e){if(j=E(i.overlap,(i.source||{}).overlap),j===!1)return!1;if("function"==typeof j&&!j(e,i))return!1}}return!0}
// Given an event input from the API, produces an array of event objects. Possible event inputs:
// 'businessHours'
// An event ID (number or string)
// An object with specific start/end dates or a recurring event (like what businessHours accepts)
function I(a){return"businessHours"===a?A():"object"==typeof a?w(u(a)):r(a)}
// Is the event's date ranged fully contained by the given range?
// start/end already assumed to have stripped zones :(
function J(a,b,c){var d=a.start.clone().stripZone(),e=L.getEventEnd(a).stripZone();return b>=d&&e>=c}
// Does the event's date range intersect with the given range?
// start/end already assumed to have stripped zones :(
function K(a,b,c){var d=a.start.clone().stripZone(),e=L.getEventEnd(a).stripZone();return e>b&&c>d}// assumed to be a calendar
var L=this;
// exports
L.isFetchNeeded=d,L.fetchEvents=e,L.addEventSource=h,L.removeEventSource=j,L.updateEvent=n,L.renderEvent=p,L.removeEvents=q,L.clientEvents=r,L.mutateEvent=x;
// imports
var M,N,O=L.trigger,P=L.getView,Q=L.reportEvents,R=L.getEventEnd,S={events:[]},T=[S],U=0,V=0,W=0,X=[];// holds events that have already been expanded
a.each((c.events?[c.events]:[]).concat(c.eventSources||[]),function(a,b){var c=i(b);c&&T.push(c)});var Y=["title","url","allDay","className","editable","color","backgroundColor","borderColor","textColor"];/* Business Hours
	-----------------------------------------------------------------------------------------*/
L.getBusinessHoursEvents=A,/* Overlapping / Constraining
	-----------------------------------------------------------------------------------------*/
L.isEventAllowedInRange=C,L.isSelectionAllowedInRange=F,L.isExternalDragAllowedInRange=G}
// updates the "backup" properties, which are preserved in order to compute diffs later on.
function k(a){a._allDay=a.allDay,a._start=a.start.clone(),a._end=a.end?a.end.clone():null}/* FullCalendar-specific DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/
// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
function l(a,b){b.left&&a.css({"border-left-width":1,"margin-left":b.left-1}),b.right&&a.css({"border-right-width":1,"margin-right":b.right-1})}
// Undoes compensateScroll and restores all borders/margins
function m(a){a.css({"margin-left":"","margin-right":"","border-left-width":"","border-right-width":""})}
// Make the mouse cursor express that an event is not allowed in the current area
function n(){a("body").addClass("fc-not-allowed")}
// Returns the mouse cursor to its original look
function o(){a("body").removeClass("fc-not-allowed")}
// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and 
// reduces the available height.
function p(b,c,d){
// *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
// and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.
var e=Math.floor(c/b.length),f=Math.floor(c-e*(b.length-1)),g=[],h=[],i=[],j=0;q(b),// give all elements their natural height
// find elements that are below the recommended height (expandable).
// important to query for heights in a single first pass (to avoid reflow oscillation).
b.each(function(c,d){var k=c===b.length-1?f:e,l=a(d).outerHeight(!0);k>l?(g.push(d),h.push(l),i.push(a(d).height())):
// this element stretches past recommended height (non-expandable). mark the space as occupied.
j+=l}),
// readjust the recommended height to only consider the height available to non-maxed-out rows.
d&&(c-=j,e=Math.floor(c/g.length),f=Math.floor(c-e*(g.length-1))),
// assign heights to all expandable elements
a(g).each(function(b,c){var d=b===g.length-1?f:e,j=h[b],k=i[b],l=d-(j-k);// subtract the margin/padding
d>j&&// we check this again because redistribution might have changed things
a(c).height(l)})}
// Undoes distrubuteHeight, restoring all els to their natural height
function q(a){a.height("")}
// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
function r(b){var c=0;// sometimes not accurate of width the text needs to stay on one line. insurance
return b.find("> *").each(function(b,d){var e=a(d).outerWidth();e>c&&(c=e)}),c++,b.width(c),c}
// Turns a container element into a scroller if its contents is taller than the allotted height.
// Returns true if the element is now a scroller, false otherwise.
// NOTE: this method is best because it takes weird zooming dimensions into account
function s(a,b){
// are scrollbars needed?
// are scrollbars needed?
return a.height(b).addClass("fc-scroller"),a[0].scrollHeight-1>a[0].clientHeight?!0:(t(a),!1)}
// Takes an element that might have been a scroller, and turns it back into a normal element.
function t(a){a.height("").removeClass("fc-scroller")}/* General DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/
// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51
function u(b){var c=b.css("position"),d=b.parents().filter(function(){var b=a(this);return/(auto|scroll)/.test(b.css("overflow")+b.css("overflow-y")+b.css("overflow-x"))}).eq(0);return"fixed"!==c&&d.length?d:a(b[0].ownerDocument||document)}
// Given a container element, return an object with the pixel values of the left/right scrollbars.
// Left scrollbars might occur on RTL browsers (IE maybe?) but I have not tested.
// PREREQUISITE: container element must have a single child with display:block
function v(a){var b=a.offset().left,c=b+a.width(),d=a.children(),e=d.offset().left,f=e+d.outerWidth();return{left:e-b,right:c-f}}
// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
function w(a){return 1==a.which&&!a.ctrlKey}/* FullCalendar-specific Misc Utilities
----------------------------------------------------------------------------------------------------------------------*/
// Creates a basic segment with the intersection of the two ranges. Returns undefined if no intersection.
// Expects all dates to be normalized to the same timezone beforehand.
function x(a,b,c,d){var e,f,g,h;// in bounds at all?
return b>c&&d>a?(a>=c?(e=a.clone(),g=!0):(e=c.clone(),g=!1),d>=b?(f=b.clone(),h=!0):(f=d.clone(),h=!1),{start:e,end:f,isStart:g,isEnd:h}):void 0}function y(a,b){if(a=a||{},void 0!==a[b])return a[b];for(var c,d=b.split(/(?=[A-Z])/),e=d.length-1;e>=0;e--)if(c=a[d[e].toLowerCase()],void 0!==c)return c;return a["default"]}
// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
function z(a,c){return b.duration({days:a.clone().stripTime().diff(c.clone().stripTime(),"days"),ms:a.time()-c.time()})}function A(a){return"[object Date]"===Object.prototype.toString.call(a)||a instanceof Date}
// Returns a boolean about whether the given input is a time string, like "06:40:00" or "06:00"
function B(a){return/^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(a)}// export
// Create an object that has the given prototype. Just like Object.create
function C(a){var b=function(){};return b.prototype=a,new b}function D(b,c,d){if(a.isFunction(b)&&(b=[b]),b){var e,f;for(e=0;e<b.length;e++)f=b[e].apply(c,d)||f;return f}}function E(){for(var a=0;a<arguments.length;a++)if(void 0!==arguments[a])return arguments[a]}function F(a){return(a+"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/'/g,"&#039;").replace(/"/g,"&quot;").replace(/\n/g,"<br />")}function G(a){return a.replace(/&.*?;/g,"")}function H(a){return a.charAt(0).toUpperCase()+a.slice(1)}function I(a,b){// for .sort()
return a-b}
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds.
// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
function J(a,b){var c,d,e,f,g=function(){var h=+new Date-f;b>h&&h>0?c=setTimeout(g,b-h):(c=null,a.apply(e,d),c||(e=d=null))};return function(){e=this,d=arguments,f=+new Date,c||(c=setTimeout(g,b))}}
// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
function K(c,d,e){var f,g,h,i,j=c[0],k=1==c.length&&"string"==typeof j;// flag for extended functionality
// clone it
// "parsing" is required
// accept strings like '2014-05', but convert to the first of the month
// for when we pass it on to moment's constructor
// no time part?
// arrays have no timezone information, so assume ambiguous zone
// otherwise, probably a string with a format
// let's record the inputted zone somehow
return b.isMoment(j)?(i=b.apply(null,c),M(j,i)):A(j)||void 0===j?i=b.apply(null,c):(f=!1,g=!1,k?Ra.test(j)?(j+="-01",c=[j],f=!0,g=!0):(h=Sa.exec(j))&&(f=!h[5],g=!0):a.isArray(j)&&(g=!0),i=d?b.utc.apply(b,c):b.apply(null,c),f?(i._ambigTime=!0,i._ambigZone=!0):e&&(g?i._ambigZone=!0:k&&i.zone(j))),i._fullCalendar=!0,i}
// Misc Internals
// -------------------------------------------------------------------------------------------------
// given an array of moment-like inputs, return a parallel array w/ moments similarly ambiguated.
// for example, of one moment has ambig time, but not others, all moments will have their time stripped.
// set `preserveTime` to `true` to keep times, but only normalize zone ambiguity.
function L(a,b){var c,d=[],e=!1,f=!1;for(c=0;c<a.length;c++)d.push(Ja.moment.parseZone(a[c])),e=e||d[c]._ambigTime,f=f||d[c]._ambigZone;for(c=0;c<d.length;c++)e&&!b?d[c].stripTime():f&&d[c].stripZone();return d}
// Transfers all the flags related to ambiguous time/zone from the `src` moment to the `dest` moment
function M(a,b){a._ambigTime?b._ambigTime=!0:b._ambigTime&&(b._ambigTime=!1),a._ambigZone?b._ambigZone=!0:b._ambigZone&&(b._ambigZone=!1)}
// Sets the year/month/date/etc values of the moment from the given array.
// Inefficient because it calls each individual setter.
function N(a,b){a.year(b[0]||0).month(b[1]||0).date(b[2]||0).hours(b[3]||0).minutes(b[4]||0).seconds(b[5]||0).milliseconds(b[6]||0)}
// Single Date Formatting
// -------------------------------------------------------------------------------------------------
// call this if you want Moment's original format method to be used
function O(a,b){return Ua.format.call(a,b)}
// Formats `date` with a Moment formatting string, but allow our non-zero areas and
// additional token.
function P(a,b){return Q(a,V(b))}function Q(a,b){var c,d="";for(c=0;c<b.length;c++)d+=R(a,b[c]);return d}function R(a,b){var c,d;// a token, like "YYYY"
// a grouping of other chunks that must be non-zero
return"string"==typeof b?b:(c=b.token)?Va[c]?Va[c](a):O(a,c):b.maybe&&(d=Q(a,b.maybe),d.match(/[1-9]/))?d:""}
// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset
// Using a formatting string meant for a single date, generate a range string, like
// "Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
// If the dates are the same as far as the format string is concerned, just return a single
// rendering of one date, without any separator.
function S(a,b,c,d,e){var f;// works with moment-pre-2.8
// Expand localized format strings, like "LL" -> "MMMM D YYYY"
// BTW, this is not important for `formatDate` because it is impossible to put custom tokens
// or non-zero areas in Moment's localized format strings.
return a=Ja.moment.parseZone(a),b=Ja.moment.parseZone(b),f=(a.localeData||a.lang).call(a),c=f.longDateFormat(c)||c,d=d||" - ",T(a,b,V(c),d,e)}// expose
function T(a,b,c,d,e){var f,g,h,i,j="",k="",l="",m="",n="";
// Start at the leftmost side of the formatting string and continue until you hit a token
// that is not the same between dates.
for(g=0;g<c.length&&(f=U(a,b,c[g]),f!==!1);g++)j+=f;
// Similarly, start at the rightmost side of the formatting string and move left
for(h=c.length-1;h>g&&(f=U(a,b,c[h]),f!==!1);h--)k=f+k;
// The area in the middle is different for both of the dates.
// Collect them distinctly so we can jam them together later.
for(i=g;h>=i;i++)l+=R(a,c[i]),m+=R(b,c[i]);return(l||m)&&(n=e?m+d+l:l+d+m),j+n+k}
// TODO: week maybe?
// Given a formatting chunk, and given that both dates are similar in the regard the
// formatting chunk is concerned, format date1 against `chunk`. Otherwise, return `false`.
function U(a,b,c){var d,e;return"string"==typeof c?c:(d=c.token)&&(e=Wa[d.charAt(0)],e&&a.isSame(b,e))?O(a,d):!1}function V(a){return a in Xa?Xa[a]:Xa[a]=W(a)}
// Break the formatting string into an array of chunks
function W(a){for(var b,c=[],d=/\[([^\]]*)\]|\(([^\)]*)\)|(LT|(\w)\4*o?)|([^\w\[\(]+)/g;b=d.exec(a);)b[1]?// a literal string inside [ ... ]
c.push(b[1]):b[2]?// non-zero formatting inside ( ... )
c.push({maybe:W(b[2])}):b[3]?// a formatting token
c.push({token:b[3]}):b[5]&&// an unenclosed literal string
c.push(b[5]);return c}/* A rectangular panel that is absolutely positioned over other content
------------------------------------------------------------------------------------------------------------------------
Options:
	- className (string)
	- content (HTML string or jQuery element set)
	- parentEl
	- top
	- left
	- right (the x coord of where the right edge should be. not a "CSS" right)
	- autoHide (boolean)
	- show (callback)
	- hide (callback)
*/
function X(a){this.options=a||{}}/* A "coordinate map" converts pixel coordinates into an associated cell, which has an associated date
------------------------------------------------------------------------------------------------------------------------
Common interface:

	CoordMap.prototype = {
		build: function() {},
		getCell: function(x, y) {}
	};

*/
/* Coordinate map for a grid component
----------------------------------------------------------------------------------------------------------------------*/
function Y(a){this.grid=a}/* Coordinate map that is a combination of multiple other coordinate maps
----------------------------------------------------------------------------------------------------------------------*/
function Z(a){this.coordMaps=a}/* Tracks mouse movements over a CoordMap and raises events about which cell the mouse is over.
----------------------------------------------------------------------------------------------------------------------*/
// TODO: very useful to have a handler that gets called upon cellOut OR when dragging stops (for cleanup)
function $(a,b){this.coordMap=a,this.options=b||{}}
// Returns `true` if the cells are identically equal. `false` otherwise.
// They must have the same row, col, and be from the same grid.
// Two null values will be considered equal, as two "out of the grid" states are the same.
function _(a,b){return a||b?a&&b?a.grid===b.grid&&a.row===b.row&&a.col===b.col:!1:!0}/* Creates a clone of an element and lets it track the mouse as it moves
----------------------------------------------------------------------------------------------------------------------*/
function aa(b,c){this.options=c=c||{},this.sourceEl=b,this.parentEl=c.parentEl?a(c.parentEl):b.parent()}/* A utility class for rendering <tr> rows.
----------------------------------------------------------------------------------------------------------------------*/
// It leverages methods of the subclass and the View to determine custom rendering behavior for each row "type"
// (such as highlight rows, day rows, helper rows, etc).
function ba(a){this.view=a}/* An abstract class comprised of a "grid" of cells that each represent a specific datetime
----------------------------------------------------------------------------------------------------------------------*/
function ca(a){ba.call(this,a),// call the super-constructor
this.coordMap=new Y(this),this.elsByFill={}}/* Utilities
----------------------------------------------------------------------------------------------------------------------*/
function da(a){// returns true if background OR inverse-background
var b=fa(a);return"background"===b||"inverse-background"===b}function ea(a){return"inverse-background"===fa(a)}function fa(a){return E((a.source||{}).rendering,a.rendering)}function ga(a){var b,c,d={};for(b=0;b<a.length;b++)c=a[b],(d[c._id]||(d[c._id]=[])).push(c);return d}
// A cmp function for determining which non-inverted "ranges" (see above) happen earlier
function ha(a,b){return a.eventStartMS-b.eventStartMS}
// A cmp function for determining which segments should take visual priority
// DOES NOT WORK ON INVERTED BACKGROUND EVENTS because they have no eventStartMS/eventDurationMS
function ia(a,b){// earlier events go first
// tie? longer events go first
// tie? put all-day events first (booleans cast to 0/1)
return a.eventStartMS-b.eventStartMS||b.eventDurationMS-a.eventDurationMS||b.event.allDay-a.event.allDay||(a.event.title||"").localeCompare(b.event.title)}/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
----------------------------------------------------------------------------------------------------------------------*/
function ja(a){ca.call(this,a)}
// Computes whether two segments' columns collide. They are assumed to be in the same row.
function ka(a,b){var c,d;for(c=0;c<b.length;c++)if(d=b[c],d.leftCol<=a.rightCol&&d.rightCol>=a.leftCol)return!0;return!1}
// A cmp function for determining the leftmost event
function la(a,b){return a.leftCol-b.leftCol}/* A component that renders one or more columns of vertical time slots
----------------------------------------------------------------------------------------------------------------------*/
function ma(a){ca.call(this,a)}
// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
// Also reorders the given array by date!
function na(a){var b,c,d;if(a.sort(ia),b=oa(a),pa(b),c=b[0]){for(d=0;d<c.length;d++)qa(c[d]);for(d=0;d<c.length;d++)ra(c[d],0,0)}}
// Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
function oa(a){var b,c,d,e=[];for(b=0;b<a.length;b++){
// go through all the levels and stop on the first level where there are no collisions
for(c=a[b],d=0;d<e.length&&sa(c,e[d]).length;d++);c.level=d,(e[d]||(e[d]=[])).push(c)}return e}
// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function pa(a){var b,c,d,e,f;for(b=0;b<a.length;b++)for(c=a[b],d=0;d<c.length;d++)for(e=c[d],e.forwardSegs=[],f=b+1;f<a.length;f++)sa(e,a[f],e.forwardSegs)}
// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function qa(a){var b,c,d=a.forwardSegs,e=0;if(void 0===a.forwardPressure){// not already computed
for(b=0;b<d.length;b++)c=d[b],qa(c),e=Math.max(e,1+c.forwardPressure);a.forwardPressure=e}}
// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
// seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
//
// The segment might be part of a "series", which means consecutive segments with the same pressure
// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
// segments behind this one in the current series, and `seriesBackwardCoord` is the starting
// coordinate of the first segment in the series.
function ra(a,b,c){var d,e=a.forwardSegs;if(void 0===a.forwardCoord)// # of segments in the series
// use this segment's coordinates to computed the coordinates of the less-pressurized
// forward segments
for(// not already computed
e.length?(
// sort highest pressure first
e.sort(ua),
// this segment's forwardCoord will be calculated from the backwardCoord of the
// highest-pressure forward segment.
ra(e[0],b+1,c),a.forwardCoord=e[0].backwardCoord):
// if there are no forward segments, this segment should butt up against the edge
a.forwardCoord=1,
// calculate the backwardCoord from the forwardCoord. consider the series
a.backwardCoord=a.forwardCoord-(a.forwardCoord-c)/(// available width for series
b+1),d=0;d<e.length;d++)ra(e[d],0,a.forwardCoord)}
// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function sa(a,b,c){c=c||[];for(var d=0;d<b.length;d++)ta(a,b[d])&&c.push(b[d]);return c}
// Do these segments occupy the same vertical space?
function ta(a,b){return a.bottom>b.top&&a.top<b.bottom}
// A cmp function for determining which forward segment to rely on more when computing coordinates.
function ua(a,b){
// put higher-pressure first
// put segments that are closer to initial edge first (and favor ones with no coords yet)
// do normal sorting...
return b.forwardPressure-a.forwardPressure||(a.backwardCoord||0)-(b.backwardCoord||0)||ia(a,b)}
// We are mixing JavaScript OOP design patterns here by putting methods and member variables in the closed scope of the
// constructor. Going forward, methods should be part of the prototype.
function va(c){// the "constructor" that concerns the prototype methods
function d(b){var c=B[b];return a.isPlainObject(c)&&!g(b)?y(c,z.name):c}function e(a,b){return c.trigger.apply(c,[a,b||z].concat(Array.prototype.slice.call(arguments,2),[z]))}/* Event Editable Boolean Calculations
	------------------------------------------------------------------------------*/
function f(a){var b=a.source||{};return E(a.startEditable,b.startEditable,d("eventStartEditable"),a.editable,b.editable,d("editable"))}function h(a){var b=a.source||{};return E(a.durationEditable,b.durationEditable,d("eventDurationEditable"),a.editable,b.editable,d("editable"))}/* Event Modification Reporting
	---------------------------------------------------------------------------------*/
function i(a,b,d,f){var g=c.mutateEvent(b,d,null);e("eventDrop",a,b,g.dateDelta,function(){g.undo(),A()},f,{}),A()}function j(a,b,d,f){var g=c.mutateEvent(b,null,d);e("eventResize",a,b,g.durationDelta,function(){g.undo(),A()},f,{}),A()}
// Is the current day hidden?
// `day` is a day-of-week index (0-6), or a Moment
function k(a){return b.isMoment(a)&&(a=a.day()),G[a]}function l(){return D}
// Incrementing the current day until it is no longer a hidden day, returning a copy.
// If the initial value of `date` is not a hidden day, don't do anything.
// Pass `isExclusive` as `true` if you are dealing with an end date.
// `inc` defaults to `1` (increment one day forward each time)
function m(a,b,c){var d=a.clone();for(b=b||1;G[(d.day()+(c?b:0)+7)%7];)d.add(b,"days");return d}
//
// TRANSFORMATIONS: cell -> cell offset -> day offset -> date
//
// cell -> date (combines all transformations)
// Possible arguments:
// - row, col
// - { row:#, col: # }
function n(){var a=o.apply(null,arguments),b=p(a),c=q(b);return c}
// cell -> cell offset
// Possible arguments:
// - row, col
// - { row:#, col:# }
function o(a,b){var c=z.colCnt,d=K?-1:1,e=K?c-1:0;"object"==typeof a&&(b=a.col,a=a.row);var f=a*c+(b*d+e);// column, adjusted for RTL (dis & dit)
return f}
// cell offset -> day offset
function p(a){var b=z.start.day();// normlize cellOffset to beginning-of-week
// first date's day of week
// # of days from full weeks
// # of days from partial last week
return a+=H[b],7*Math.floor(a/D)+J[(a%D+D)%D]-b}
// day offset -> date
function q(a){return z.start.clone().add(a,"days")}
//
// TRANSFORMATIONS: date -> day offset -> cell offset -> cell
//
// date -> cell (combines all transformations)
function r(a){var b=s(a),c=t(b),d=u(c);return d}
// date -> day offset
function s(a){return a.clone().stripTime().diff(z.start,"days")}
// day offset -> cell offset
function t(a){var b=z.start.day();// normalize dayOffset to beginning-of-week
// first date's day of week
// # of cells from full weeks
// # of cells from partial last week
return a+=b,Math.floor(a/7)*D+H[(a%7+7)%7]-H[b]}
// cell offset -> cell (object with row & col keys)
function u(a){var b=z.colCnt,c=K?-1:1,d=K?b-1:0,e=Math.floor(a/b),f=(a%b+b)%b*c+d;// column, adjusted for RTL (dis & dit)
return{row:e,col:f}}
//
// Converts a date range into an array of segment objects.
// "Segments" are horizontal stretches of time, sliced up by row.
// A segment object has the following properties:
// - row
// - cols
// - isStart
// - isEnd
//
function v(a,b){
// loop through all the rows in the view
for(var c=z.rowCnt,d=z.colCnt,e=[],f=w(a,b),g=s(f.start),h=s(f.end),i=t(g),j=t(h)-1,k=0;c>k;k++){
// first and last cell offset for the row
var l=k*d,m=l+d-1,n=Math.max(i,l),o=Math.min(j,m);
// make sure segment's offsets are valid and in view
if(o>=n){
// translate to cells
var q=u(n),r=u(o),v=[q.col,r.col].sort(I),x=p(n)==g,y=p(o)+1==h;
// +1 for comparing exclusively
e.push({row:k,leftCol:v[0],rightCol:v[1],isStart:x,isEnd:y})}}return e}
// Returns the date range of the full days the given range visually appears to occupy.
// Returns object with properties `start` (moment) and `end` (moment, exclusive end).
function w(a,b){var c,d,e=a.clone().stripTime();// the beginning of the day the range exclusively ends
// # of milliseconds into `endDay`
// If the end time is actually inclusively part of the next day and is equal to or
// beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
// Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
// If no end was specified, or if it is within `startDay` but not past nextDayThreshold,
// assign the default duration of one day.
return b&&(c=b.clone().stripTime(),d=+b.time(),d&&d>=C&&c.add(1,"days")),(!b||e>=c)&&(c=e.clone().add(1,"days")),{start:e,end:c}}
// Does the given event visually appear to occupy more than one day?
function x(a){var b=w(a.start,a.end);return b.end.diff(b.start,"days")>1}var z=this;
// exports
z.calendar=c,z.opt=d,z.trigger=e,z.isEventDraggable=f,z.isEventResizable=h,z.eventDrop=i,z.eventResize=j;
// imports
var A=c.reportEventChange,B=c.options,C=b.duration(B.nextDayThreshold);z.init(),/* Event Elements
	------------------------------------------------------------------------------*/
// Compute the text that should be displayed on an event's element.
// Based off the settings of the view. Possible signatures:
//   .getEventTimeText(event, formatStr)
//   .getEventTimeText(startMoment, endMoment, formatStr)
//   .getEventTimeText(startMoment, null, formatStr)
// `timeFormat` is used but the `formatStr` argument can be used to override.
z.getEventTimeText=function(a,b){var e,f;return"object"==typeof a&&"object"==typeof b?(e=a,f=b,b=arguments[2]):(e=a.start,f=a.end),b=b||d("timeFormat"),f&&d("displayEventEnd")?c.formatRange(e,f,b):c.formatDate(e,b)},
// ====================================================================================================
// Utilities for day "cells"
// ====================================================================================================
// The "basic" views are completely made up of day cells.
// The "agenda" views have day cells at the top "all day" slot.
// This was the obvious common place to put these utilities, but they should be abstracted out into
// a more meaningful class (like DayEventRenderer).
// ====================================================================================================
// For determining how a given "cell" translates into a "date":
//
// 1. Convert the "cell" (row and column) into a "cell offset" (the # of the cell, cronologically from the first).
//    Keep in mind that column indices are inverted with isRTL. This is taken into account.
//
// 2. Convert the "cell offset" to a "day offset" (the # of days since the first visible day in the view).
//
// 3. Convert the "day offset" into a "date" (a Moment).
//
// The reverse transformation happens when transforming a date into a cell.
// exports
z.isHiddenDay=k,z.skipHiddenDays=m,z.getCellsPerWeek=l,z.dateToCell=r,z.dateToDayOffset=s,z.dayOffsetToCellOffset=t,z.cellOffsetToCell=u,z.cellToDate=n,z.cellToCellOffset=o,z.cellOffsetToDayOffset=p,z.dayOffsetToDate=q,z.rangeToSegments=v,z.isMultiDayEvent=x;
// internals
var D,F=d("hiddenDays")||[],G=[],H=[],J=[],K=d("isRTL");
// initialize important internal variables
!function(){d("weekends")===!1&&F.push(0,6);
// Loop through a hypothetical week and determine which
// days-of-week are hidden. Record in both hashes (one is the reverse of the other).
for(var b=0,c=0;7>b;b++)H[b]=c,G[b]=-1!=a.inArray(b,F),G[b]||(J[c]=b,c++);if(D=c,!D)throw"invalid hiddenDays"}()}
// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
function wa(c){var d,e,f,g,h=Ja.dataAttrPrefix;
// pluck special-cased date/time properties
// accept 'time' as well
// fallback to standalone attribute values for each of the date/time properties
// accept 'time' as well
// massage into correct data types
return h&&(h+="-"),d=c.data(h+"event")||null,d&&(d="object"==typeof d?a.extend({},d):{},e=d.start,null==e&&(e=d.time),f=d.duration,g=d.stick,delete d.start,delete d.time,delete d.duration,delete d.stick),null==e&&(e=c.data(h+"start")),null==e&&(e=c.data(h+"time")),null==f&&(f=c.data(h+"duration")),null==g&&(g=c.data(h+"stick")),e=null!=e?b.duration(e):null,f=null!=f?b.duration(f):null,g=Boolean(g),{eventProps:d,startTime:e,duration:f,stick:g}}/* An abstract class for the "basic" views, as well as month view. Renders one or more rows of day cells.
----------------------------------------------------------------------------------------------------------------------*/
// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.
function xa(a){va.call(this,a),// call the super-constructor
this.dayGrid=new ja(this),this.coordMap=this.dayGrid.coordMap}// register the view
function ya(a){xa.call(this,a)}// register this view
function za(a){xa.call(this,a)}// register this view
function Aa(a){xa.call(this,a)}function Ba(a,b){return b.longDateFormat("LT").replace(":mm","(:mm)").replace(/(\Wmm)$/,"($1)").replace(/\s*a$/i,"a")}function Ca(a,b){return b.longDateFormat("LT").replace(/\s*a$/i,"")}function Da(a){va.call(this,a),// call the super-constructor
this.timeGrid=new ma(this),this.opt("allDaySlot")?(// should we display the "all-day" area?
this.dayGrid=new ja(this),// the all-day subcomponent of this view
// the coordinate grid will be a combination of both subcomponents' grids
this.coordMap=new Z([this.dayGrid.coordMap,this.timeGrid.coordMap])):this.coordMap=this.timeGrid.coordMap}// register the view
function Ea(a){Da.call(this,a)}// register the view
function Fa(a){Da.call(this,a)}var Ga={lang:"en",defaultTimedEventDuration:"02:00:00",defaultAllDayEventDuration:{days:1},forceEventDuration:!1,nextDayThreshold:"09:00:00",// 9am
// display
defaultView:"month",aspectRatio:1.35,header:{left:"title",center:"",right:"today prev,next"},weekends:!0,weekNumbers:!1,weekNumberTitle:"W",weekNumberCalculation:"local",
//editable: false,
// event ajax
lazyFetching:!0,startParam:"start",endParam:"end",timezoneParam:"timezone",timezone:!1,
//allDayDefault: undefined,
// time formats
titleFormat:{month:"MMMM YYYY",// like "September 1986". each language will override this
week:"ll",// like "Sep 4 1986"
day:"LL"},columnFormat:{month:"ddd",// like "Sat"
week:d,day:"dddd"},timeFormat:{// for event elements
"default":c},displayEventEnd:{month:!1,basicWeek:!1,"default":!0},
// locale
isRTL:!1,defaultButtonText:{prev:"prev",next:"next",prevYear:"prev year",nextYear:"next year",today:"today",month:"month",week:"week",day:"day"},buttonIcons:{prev:"left-single-arrow",next:"right-single-arrow",prevYear:"left-double-arrow",nextYear:"right-double-arrow"},
// jquery-ui theming
theme:!1,themeButtonIcons:{prev:"circle-triangle-w",next:"circle-triangle-e",prevYear:"seek-prev",nextYear:"seek-next"},dragOpacity:.75,dragRevertDuration:500,dragScroll:!0,
//selectable: false,
unselectAuto:!0,dropAccept:"*",eventLimit:!1,eventLimitText:"more",eventLimitClick:"popover",dayPopoverFormat:"LL",handleWindowResize:!0,windowResizeDelay:200},Ha={en:{columnFormat:{week:"ddd M/D"},dayPopoverFormat:"dddd, MMMM D"}},Ia={header:{left:"next,prev today",center:"",right:"title"},buttonIcons:{prev:"right-single-arrow",next:"left-single-arrow",prevYear:"right-double-arrow",nextYear:"left-double-arrow"},themeButtonIcons:{prev:"circle-triangle-e",next:"circle-triangle-w",nextYear:"seek-prev",prevYear:"seek-next"}},Ja=a.fullCalendar={version:"2.2.3"},Ka=Ja.views={};a.fn.fullCalendar=function(b){var c=Array.prototype.slice.call(arguments,1),d=this;// what this function will return (this jQuery object by default)
return this.each(function(e,f){// loop each DOM element involved
var g,i=a(f),j=i.data("fullCalendar");// the returned value of this single method call
// a method call
"string"==typeof b?j&&a.isFunction(j[b])&&(g=j[b].apply(j,c),e||(d=g),"destroy"===b&&i.removeData("fullCalendar")):j||(j=new h(i,b),i.data("fullCalendar",j),j.render())}),d},
//var langOptionHash = {}; // initialized in defaults.js
Ja.langs=Ha,// expose
// Initialize jQuery UI Datepicker translations while using some of the translations
// for our own purposes. Will set this as the default language for datepicker.
// Called from a translation file.
Ja.datepickerLang=function(b,c,d){var e=Ha[b];
// initialize FullCalendar's lang hash for this language
e||(e=Ha[b]={}),
// merge certain Datepicker options into FullCalendar's options
f(e,{isRTL:d.isRTL,weekNumberTitle:d.weekHeader,titleFormat:{month:d.showMonthAfterYear?"YYYY["+d.yearSuffix+"] MMMM":"MMMM YYYY["+d.yearSuffix+"]"},defaultButtonText:{
// the translations sometimes wrongly contain HTML entities
prev:G(d.prevText),next:G(d.nextText),today:G(d.currentText)}}),
// is jQuery UI Datepicker is on the page?
a.datepicker&&(
// Register the language data.
// FullCalendar and MomentJS use language codes like "pt-br" but Datepicker
// does it like "pt-BR" or if it doesn't have the language, maybe just "pt".
// Make an alias so the language can be referenced either way.
a.datepicker.regional[c]=a.datepicker.regional[b]=// alias
d,
// Alias 'en' to the default language data. Do this every time.
a.datepicker.regional.en=a.datepicker.regional[""],
// Set as Datepicker's global defaults.
a.datepicker.setDefaults(d))},
// Sets FullCalendar-specific translations. Also sets the language as the global default.
// Called from a translation file.
Ja.lang=function(a,b){var c;b&&(c=Ha[a],c||(c=Ha[a]={}),f(c,b||{})),
// set it as the default language for FullCalendar
Ga.lang=a},Ja.sourceNormalizers=[],Ja.sourceFetchers=[];var La={dataType:"json",cache:!1},Ma=1,Na=["sun","mon","tue","wed","thu","fri","sat"];/* General Utilities
----------------------------------------------------------------------------------------------------------------------*/
Ja.applyAll=D;var Oa,Pa,Qa,Ra=/^\s*\d{4}-\d\d$/,Sa=/^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/,Ta=b.fn,Ua=a.extend({},Ta);// function defined below
// Creating
// -------------------------------------------------------------------------------------------------
// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
Ja.moment=function(){return K(arguments)},
// Sames as fc.moment, but forces the resulting moment to be in the UTC timezone.
Ja.moment.utc=function(){var a=K(arguments,!0);
// Force it into UTC because makeMoment doesn't guarantee it
// (if given a pre-existing moment for example)
// don't give ambiguously-timed moments a UTC zone
return a.hasTime()&&a.utc(),a},
// Same as fc.moment, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
Ja.moment.parseZone=function(){return K(arguments,!0,!0)},
// A clone method that works with the flags related to our enhanced functionality.
// In the future, use moment.momentProperties
Ta.clone=function(){var a=Ua.clone.apply(this,arguments);
// these flags weren't transfered with the clone
return M(this,a),this._fullCalendar&&(a._fullCalendar=!0),a},
// Time-of-day
// -------------------------------------------------------------------------------------------------
// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
Ta.time=function(a){
// Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
// `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
if(!this._fullCalendar)return Ua.time.apply(this,arguments);if(null==a)// getter
return b.duration({hours:this.hours(),minutes:this.minutes(),seconds:this.seconds(),milliseconds:this.milliseconds()});// setter
this._ambigTime=!1,// mark that the moment now has a time
b.isDuration(a)||b.isMoment(a)||(a=b.duration(a));
// The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
// Only for Duration times, not Moment times.
var c=0;
// We need to set the individual fields.
// Can't use startOf('day') then add duration. In case of DST at start of day.
return b.isDuration(a)&&(c=24*Math.floor(a.asDays())),this.hours(c+a.hours()).minutes(a.minutes()).seconds(a.seconds()).milliseconds(a.milliseconds())},
// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
Ta.stripTime=function(){var a=this.toArray();// if ambiguous time, also ambiguous timezone offset
// year,month,date,hours,minutes,seconds as an array
// set the internal UTC flag (will clear the ambig flags)
// set the year/month/date. time will be zero
// Mark the time as ambiguous. This needs to happen after the .utc() call, which calls .zone(),
// which clears all ambig flags. Same with setUTCValues with moment-timezone.
return this.utc(),Pa(this,a.slice(0,3)),this._ambigTime=!0,this._ambigZone=!0,this},
// Returns if the moment has a non-ambiguous time (boolean)
Ta.hasTime=function(){return!this._ambigTime},
// Timezone
// -------------------------------------------------------------------------------------------------
// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
Ta.stripZone=function(){var a=this.toArray(),b=this._ambigTime;// set the internal UTC flag (will clear the ambig flags)
// will set the year/month/date/hours/minutes/seconds/ms
// the above call to .utc()/.zone() unfortunately clears the ambig flags, so reassign
// Mark the zone as ambiguous. This needs to happen after the .utc() call, which calls .zone(),
// which clears all ambig flags. Same with setUTCValues with moment-timezone.
return this.utc(),Pa(this,a),b&&(this._ambigTime=!0),this._ambigZone=!0,this},
// Returns of the moment has a non-ambiguous timezone offset (boolean)
Ta.hasZone=function(){return!this._ambigZone},
// this method implicitly marks a zone (will get called upon .utc() and .local())
Ta.zone=function(a){// setter
// these assignments needs to happen before the original zone method is called.
// I forget why, something to do with a browser crash.
return null!=a&&(this._ambigTime=!1,this._ambigZone=!1),Ua.zone.apply(this,arguments)},
// this method implicitly marks a zone
Ta.local=function(){var a=this.toArray(),b=this._ambigZone;// will clear ambig flags
// If the moment was ambiguously zoned, the date fields were stored as UTC.
// We want to preserve these, but in local time.
return Ua.local.apply(this,arguments),b&&Qa(this,a),this},
// Formatting
// -------------------------------------------------------------------------------------------------
Ta.format=function(){return this._fullCalendar&&arguments[0]?P(this,arguments[0]):this._ambigTime?O(this,"YYYY-MM-DD"):this._ambigZone?O(this,"YYYY-MM-DD[T]HH:mm:ss"):Ua.format.apply(this,arguments)},Ta.toISOString=function(){return this._ambigTime?O(this,"YYYY-MM-DD"):this._ambigZone?O(this,"YYYY-MM-DD[T]HH:mm:ss"):Ua.toISOString.apply(this,arguments)},
// Querying
// -------------------------------------------------------------------------------------------------
// Is the moment within the specified range? `end` is exclusive.
// FYI, this method is not a standard Moment method, so always do our enhanced logic.
Ta.isWithin=function(a,b){var c=L([this,a,b]);return c[0]>=c[1]&&c[0]<c[2]},
// When isSame is called with units, timezone ambiguity is normalized before the comparison happens.
// If no units specified, the two moments must be identically the same, with matching ambig flags.
Ta.isSame=function(a,b){var c;
// only do custom logic if this is an enhanced moment
// only do custom logic if this is an enhanced moment
return this._fullCalendar?b?(c=L([this,a],!0),Ua.isSame.call(c[0],c[1],b)):(a=Ja.moment.parseZone(a),Ua.isSame.call(this,a)&&Boolean(this._ambigTime)===Boolean(a._ambigTime)&&Boolean(this._ambigZone)===Boolean(a._ambigZone)):Ua.isSame.apply(this,arguments)},
// Make these query methods work with ambiguous moments
a.each(["isBefore","isAfter"],function(a,b){Ta[b]=function(a,c){var d;
// only do custom logic if this is an enhanced moment
// only do custom logic if this is an enhanced moment
return this._fullCalendar?(d=L([this,a]),Ua[b].call(d[0],d[1],c)):Ua[b].apply(this,arguments)}}),Oa="_d"in b()&&"updateOffset"in b,Pa=Oa?function(a,c){a._d.setTime(Date.UTC.apply(Date,c)),b.updateOffset(a,!1)}:N,Qa=Oa?function(a,c){a._d.setTime(+new Date(c[0]||0,c[1]||0,c[2]||0,c[3]||0,c[4]||0,c[5]||0,c[6]||0)),b.updateOffset(a,!1)}:N;
// addition formatting tokens we want recognized
var Va={t:function(a){// "a" or "p"
return O(a,"a").charAt(0)},T:function(a){// "A" or "P"
return O(a,"A").charAt(0)}};Ja.formatRange=S;var Wa={Y:"year",M:"month",D:"day",// day of month
d:"day",// day of week
// prevents a separator between anything time-related...
A:"second",// AM/PM
a:"second",// am/pm
T:"second",// A/P
t:"second",// a/p
H:"second",// hour (24)
h:"second",// hour (12)
m:"second",// minute
s:"second"},Xa={};X.prototype={isHidden:!0,options:null,el:null,// the container element for the popover. generated by this object
documentMousedownProxy:null,// document mousedown handler bound to `this`
margin:10,// the space required between the popover and the edges of the scroll container
// Shows the popover on the specified position. Renders it if not already
show:function(){this.isHidden&&(this.el||this.render(),this.el.show(),this.position(),this.isHidden=!1,this.trigger("show"))},
// Hides the popover, through CSS, but does not remove it from the DOM
hide:function(){this.isHidden||(this.el.hide(),this.isHidden=!0,this.trigger("hide"))},
// Creates `this.el` and renders content inside of it
render:function(){var b=this,c=this.options;this.el=a('<div class="fc-popover"/>').addClass(c.className||"").css({
// position initially to the top left to avoid creating scrollbars
top:0,left:0}).append(c.content).appendTo(c.parentEl),
// when a click happens on anything inside with a 'fc-close' className, hide the popover
this.el.on("click",".fc-close",function(){b.hide()}),c.autoHide&&a(document).on("mousedown",this.documentMousedownProxy=a.proxy(this,"documentMousedown"))},
// Triggered when the user clicks *anywhere* in the document, for the autoHide feature
documentMousedown:function(b){
// only hide the popover if the click happened outside the popover
this.el&&!a(b.target).closest(this.el).length&&this.hide()},
// Hides and unregisters any handlers
destroy:function(){this.hide(),this.el&&(this.el.remove(),this.el=null),a(document).off("mousedown",this.documentMousedownProxy)},
// Positions the popover optimally, using the top/left/right options
position:function(){var b,c,d,e,f,g=this.options,h=this.el.offsetParent().offset(),i=this.el.outerWidth(),j=this.el.outerHeight(),k=a(window),l=u(this.el);e=g.top||0,f=void 0!==g.left?g.left:void 0!==g.right?g.right-i:0,l.is(window)||l.is(document)?(l=k,b=0,c=0):(d=l.offset(),b=d.top,c=d.left),b+=k.scrollTop(),c+=k.scrollLeft(),g.viewportConstrain!==!1&&(e=Math.min(e,b+l.outerHeight()-j-this.margin),e=Math.max(e,b+this.margin),f=Math.min(f,c+l.outerWidth()-i-this.margin),f=Math.max(f,c+this.margin)),this.el.css({top:e-h.top,left:f-h.left})},
// Triggers a callback. Calls a function in the option hash of the same name.
// Arguments beyond the first `name` are forwarded on.
// TODO: better code reuse for this. Repeat code
trigger:function(a){this.options[a]&&this.options[a].apply(this,Array.prototype.slice.call(arguments,1))}},Y.prototype={grid:null,// reference to the Grid
rows:null,// the top-to-bottom y coordinates. including the bottom of the last item
cols:null,// the left-to-right x coordinates. including the right of the last item
containerEl:null,// container element that all coordinates are constrained to. optionally assigned
minX:null,maxX:null,// exclusive
minY:null,maxY:null,// exclusive
// Queries the grid for the coordinates of all the cells
build:function(){this.grid.buildCoords(this.rows=[],this.cols=[]),this.computeBounds()},
// Given a coordinate of the document, gets the associated cell. If no cell is underneath, returns null
getCell:function(a,b){var c,d=null,e=this.rows,f=this.cols,g=-1,h=-1;if(this.inBounds(a,b)){for(c=0;c<e.length;c++)if(b>=e[c][0]&&b<e[c][1]){g=c;break}for(c=0;c<f.length;c++)if(a>=f[c][0]&&a<f[c][1]){h=c;break}g>=0&&h>=0&&(d={row:g,col:h},d.grid=this.grid,d.date=this.grid.getCellDate(d))}return d},
// If there is a containerEl, compute the bounds into min/max values
computeBounds:function(){var a;this.containerEl&&(a=this.containerEl.offset(),this.minX=a.left,this.maxX=a.left+this.containerEl.outerWidth(),this.minY=a.top,this.maxY=a.top+this.containerEl.outerHeight())},
// Determines if the given coordinates are in bounds. If no `containerEl`, always true
inBounds:function(a,b){return this.containerEl?a>=this.minX&&a<this.maxX&&b>=this.minY&&b<this.maxY:!0}},Z.prototype={coordMaps:null,// an array of CoordMaps
// Builds all coordMaps
build:function(){var a,b=this.coordMaps;for(a=0;a<b.length;a++)b[a].build()},
// Queries all coordMaps for the cell underneath the given coordinates, returning the first result
getCell:function(a,b){var c,d=this.coordMaps,e=null;for(c=0;c<d.length&&!e;c++)e=d[c].getCell(a,b);return e}},$.prototype={coordMap:null,options:null,isListening:!1,isDragging:!1,
// the cell/date the mouse was over when listening started
origCell:null,origDate:null,
// the cell/date the mouse is over
cell:null,date:null,
// coordinates of the initial mousedown
mouseX0:null,mouseY0:null,
// handler attached to the document, bound to the DragListener's `this`
mousemoveProxy:null,mouseupProxy:null,scrollEl:null,scrollBounds:null,// { top, bottom, left, right }
scrollTopVel:null,// pixels per second
scrollLeftVel:null,// pixels per second
scrollIntervalId:null,// ID of setTimeout for scrolling animation loop
scrollHandlerProxy:null,// this-scoped function for handling when scrollEl is scrolled
scrollSensitivity:30,// pixels from edge for scrolling to start
scrollSpeed:200,// pixels per second, at maximum speed
scrollIntervalMs:50,// millisecond wait between scroll increment
// Call this when the user does a mousedown. Will probably lead to startListening
mousedown:function(a){w(a)&&(a.preventDefault(),// prevents native selection in most browsers
this.startListening(a),
// start the drag immediately if there is no minimum distance for a drag start
this.options.distance||this.startDrag(a))},
// Call this to start tracking mouse movements
startListening:function(b){var c,d;this.isListening||(
// grab scroll container and attach handler
b&&this.options.scroll&&(c=u(a(b.target)),c.is(window)||c.is(document)||(this.scrollEl=c,this.scrollHandlerProxy=J(a.proxy(this,"scrollHandler"),100),this.scrollEl.on("scroll",this.scrollHandlerProxy))),this.computeCoords(),// relies on `scrollEl`
// get info on the initial cell, date, and coordinates
b&&(d=this.getCell(b),this.origCell=d,this.origDate=d?d.date:null,this.mouseX0=b.pageX,this.mouseY0=b.pageY),a(document).on("mousemove",this.mousemoveProxy=a.proxy(this,"mousemove")).on("mouseup",this.mouseupProxy=a.proxy(this,"mouseup")).on("selectstart",this.preventDefault),// prevents native selection in IE<=8
this.isListening=!0,this.trigger("listenStart",b))},
// Recomputes the drag-critical positions of elements
computeCoords:function(){this.coordMap.build(),this.computeScrollBounds()},
// Called when the user moves the mouse
mousemove:function(a){var b,c;// current distance from mouseX0/mouseY0, squared
this.isDragging||(b=this.options.distance||1,c=Math.pow(a.pageX-this.mouseX0,2)+Math.pow(a.pageY-this.mouseY0,2),c>=b*b&&this.startDrag(a)),this.isDragging&&this.drag(a)},
// Call this to initiate a legitimate drag.
// This function is called internally from this class, but can also be called explicitly from outside
startDrag:function(a){var b;this.isListening||// startDrag must have manually initiated
this.startListening(),this.isDragging||(this.isDragging=!0,this.trigger("dragStart",a),b=this.getCell(a),b&&this.cellOver(b,!0))},
// Called while the mouse is being moved and when we know a legitimate drag is taking place
drag:function(a){var b;this.isDragging&&(b=this.getCell(a),_(b,this.cell)||(this.cell&&this.cellOut(),b&&this.cellOver(b)),this.dragScroll(a))},
// Called when a the mouse has just moved over a new cell
cellOver:function(a){this.cell=a,this.date=a.date,this.trigger("cellOver",a,a.date)},
// Called when the mouse has just moved out of a cell
cellOut:function(){this.cell&&(this.trigger("cellOut",this.cell),this.cell=null,this.date=null)},
// Called when the user does a mouseup
mouseup:function(a){this.stopDrag(a),this.stopListening(a)},
// Called when the drag is over. Will not cause listening to stop however.
// A concluding 'cellOut' event will NOT be triggered.
stopDrag:function(a){this.isDragging&&(this.stopScrolling(),this.trigger("dragStop",a),this.isDragging=!1)},
// Call this to stop listening to the user's mouse events
stopListening:function(b){this.isListening&&(
// remove the scroll handler if there is a scrollEl
this.scrollEl&&(this.scrollEl.off("scroll",this.scrollHandlerProxy),this.scrollHandlerProxy=null),a(document).off("mousemove",this.mousemoveProxy).off("mouseup",this.mouseupProxy).off("selectstart",this.preventDefault),this.mousemoveProxy=null,this.mouseupProxy=null,this.isListening=!1,this.trigger("listenStop",b),this.origCell=this.cell=null,this.origDate=this.date=null)},
// Gets the cell underneath the coordinates for the given mouse event
getCell:function(a){return this.coordMap.getCell(a.pageX,a.pageY)},
// Triggers a callback. Calls a function in the option hash of the same name.
// Arguments beyond the first `name` are forwarded on.
trigger:function(a){this.options[a]&&this.options[a].apply(this,Array.prototype.slice.call(arguments,1))},
// Stops a given mouse event from doing it's native browser action. In our case, text selection.
preventDefault:function(a){a.preventDefault()},/* Scrolling
	------------------------------------------------------------------------------------------------------------------*/
// Computes and stores the bounding rectangle of scrollEl
computeScrollBounds:function(){var a,b=this.scrollEl;b&&(a=b.offset(),this.scrollBounds={top:a.top,left:a.left,bottom:a.top+b.outerHeight(),right:a.left+b.outerWidth()})},
// Called when the dragging is in progress and scrolling should be updated
dragScroll:function(a){var b,c,d,e,f=this.scrollSensitivity,g=this.scrollBounds,h=0,i=0;g&&(b=(f-(a.pageY-g.top))/f,c=(f-(g.bottom-a.pageY))/f,d=(f-(a.pageX-g.left))/f,e=(f-(g.right-a.pageX))/f,b>=0&&1>=b?h=b*this.scrollSpeed*-1:c>=0&&1>=c&&(h=c*this.scrollSpeed),d>=0&&1>=d?i=d*this.scrollSpeed*-1:e>=0&&1>=e&&(i=e*this.scrollSpeed)),this.setScrollVel(h,i)},
// Sets the speed-of-scrolling for the scrollEl
setScrollVel:function(b,c){this.scrollTopVel=b,this.scrollLeftVel=c,this.constrainScrollVel(),// massages into realistic values
// if there is non-zero velocity, and an animation loop hasn't already started, then START
!this.scrollTopVel&&!this.scrollLeftVel||this.scrollIntervalId||(this.scrollIntervalId=setInterval(a.proxy(this,"scrollIntervalFunc"),// scope to `this`
this.scrollIntervalMs))},
// Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
constrainScrollVel:function(){var a=this.scrollEl;this.scrollTopVel<0?// scrolling up?
a.scrollTop()<=0&&(// already scrolled all the way up?
this.scrollTopVel=0):this.scrollTopVel>0&&a.scrollTop()+a[0].clientHeight>=a[0].scrollHeight&&(// already scrolled all the way down?
this.scrollTopVel=0),this.scrollLeftVel<0?// scrolling left?
a.scrollLeft()<=0&&(// already scrolled all the left?
this.scrollLeftVel=0):this.scrollLeftVel>0&&a.scrollLeft()+a[0].clientWidth>=a[0].scrollWidth&&(// already scrolled all the way right?
this.scrollLeftVel=0)},
// This function gets called during every iteration of the scrolling animation loop
scrollIntervalFunc:function(){var a=this.scrollEl,b=this.scrollIntervalMs/1e3;// considering animation frequency, what the vel should be mult'd by
// change the value of scrollEl's scroll
this.scrollTopVel&&a.scrollTop(a.scrollTop()+this.scrollTopVel*b),this.scrollLeftVel&&a.scrollLeft(a.scrollLeft()+this.scrollLeftVel*b),this.constrainScrollVel(),// since the scroll values changed, recompute the velocities
// if scrolled all the way, which causes the vels to be zero, stop the animation loop
this.scrollTopVel||this.scrollLeftVel||this.stopScrolling()},
// Kills any existing scrolling animation loop
stopScrolling:function(){this.scrollIntervalId&&(clearInterval(this.scrollIntervalId),this.scrollIntervalId=null,
// when all done with scrolling, recompute positions since they probably changed
this.computeCoords())},
// Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
scrollHandler:function(){
// recompute all coordinates, but *only* if this is *not* part of our scrolling animation
this.scrollIntervalId||this.computeCoords()}},aa.prototype={options:null,sourceEl:null,// the element that will be cloned and made to look like it is dragging
el:null,// the clone of `sourceEl` that will track the mouse
parentEl:null,// the element that `el` (the clone) will be attached to
// the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl
top0:null,left0:null,
// the initial position of the mouse
mouseY0:null,mouseX0:null,
// the number of pixels the mouse has moved from its initial position
topDelta:null,leftDelta:null,mousemoveProxy:null,// document mousemove handler, bound to the MouseFollower's `this`
isFollowing:!1,isHidden:!1,isAnimating:!1,// doing the revert animation?
// Causes the element to start following the mouse
start:function(b){this.isFollowing||(this.isFollowing=!0,this.mouseY0=b.pageY,this.mouseX0=b.pageX,this.topDelta=0,this.leftDelta=0,this.isHidden||this.updatePosition(),a(document).on("mousemove",this.mousemoveProxy=a.proxy(this,"mousemove")))},
// Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
// `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
stop:function(b,c){function d(){this.isAnimating=!1,e.destroyEl(),this.top0=this.left0=null,// reset state for future updatePosition calls
c&&c()}var e=this,f=this.options.revertDuration;this.isFollowing&&!this.isAnimating&&(// disallow more than one stop animation at a time
this.isFollowing=!1,a(document).off("mousemove",this.mousemoveProxy),b&&f&&!this.isHidden?(// do a revert animation?
this.isAnimating=!0,this.el.animate({top:this.top0,left:this.left0},{duration:f,complete:d})):d())},
// Gets the tracking element. Create it if necessary
getEl:function(){var a=this.el;// hack to force IE8 to compute correct bounding box
return a||(this.sourceEl.width(),a=this.el=this.sourceEl.clone().css({position:"absolute",visibility:"",// in case original element was hidden (commonly through hideEvents())
display:this.isHidden?"none":"",// for when initially hidden
margin:0,right:"auto",// erase and set width instead
bottom:"auto",// erase and set height instead
width:this.sourceEl.width(),// explicit height in case there was a 'right' value
height:this.sourceEl.height(),// explicit width in case there was a 'bottom' value
opacity:this.options.opacity||"",zIndex:this.options.zIndex}).appendTo(this.parentEl)),a},
// Removes the tracking element if it has already been created
destroyEl:function(){this.el&&(this.el.remove(),this.el=null)},
// Update the CSS position of the tracking element
updatePosition:function(){var a,b;this.getEl(),// ensure this.el
// make sure origin info was computed
null===this.top0&&(this.sourceEl.width(),a=this.sourceEl.offset(),b=this.el.offsetParent().offset(),this.top0=a.top-b.top,this.left0=a.left-b.left),this.el.css({top:this.top0+this.topDelta,left:this.left0+this.leftDelta})},
// Gets called when the user moves the mouse
mousemove:function(a){this.topDelta=a.pageY-this.mouseY0,this.leftDelta=a.pageX-this.mouseX0,this.isHidden||this.updatePosition()},
// Temporarily makes the tracking element invisible. Can be called before following starts
hide:function(){this.isHidden||(this.isHidden=!0,this.el&&this.el.hide())},
// Show the tracking element after it has been temporarily hidden
show:function(){this.isHidden&&(this.isHidden=!1,this.updatePosition(),this.getEl().show())}},ba.prototype={view:null,// a View object
cellHtml:"<td/>",// plain default HTML used for a cell when no other is available
// Renders the HTML for a row, leveraging custom cell-HTML-renderers based on the `rowType`.
// Also applies the "intro" and "outro" cells, which are specified by the subclass and views.
// `row` is an optional row number.
rowHtml:function(a,b){var c,d,e=this.view,f=this.getHtmlRenderer("cell",a),g="";for(b=b||0,c=0;c<e.colCnt;c++)d=e.cellToDate(b,c),g+=f(b,c,d);// apply intro and outro
return g=this.bookendCells(g,a,b),"<tr>"+g+"</tr>"},
// Applies the "intro" and "outro" HTML to the given cells.
// Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
// `cells` can be an HTML string of <td>'s or a jQuery <tr> element
// `row` is an optional row number.
bookendCells:function(a,b,c){var d=this.view,e=this.getHtmlRenderer("intro",b)(c||0),f=this.getHtmlRenderer("outro",b)(c||0),g=d.opt("isRTL"),h=g?f:e,i=g?e:f;return"string"==typeof a?h+a+i:a.prepend(h).append(i)},
// Returns an HTML-rendering function given a specific `rendererName` (like cell, intro, or outro) and a specific
// `rowType` (like day, eventSkeleton, helperSkeleton), which is optional.
// If a renderer for the specific rowType doesn't exist, it will fall back to a generic renderer.
// We will query the View object first for any custom rendering functions, then the methods of the subclass.
getHtmlRenderer:function(a,b){var c,d,e,f,g=this.view;return c=a+"Html",b&&(d=b+H(a)+"Html"),d&&(f=g[d])?e=g:d&&(f=this[d])?e=this:(f=g[c])?e=g:(f=this[c])&&(e=this),"function"==typeof f?function(){return f.apply(e,arguments)||""}:function(){return f||""}}},ca.prototype=C(ba.prototype),// declare the super-class
a.extend(ca.prototype,{el:null,// the containing element
coordMap:null,// a GridCoordMap that converts pixel values to datetimes
cellDuration:null,// a cell's duration. subclasses must assign this ASAP
elsByFill:null,// a hash of jQuery element sets used for rendering each fill. Keyed by fill name.
// Renders the grid into the `el` element.
// Subclasses should override and call this super-method when done.
render:function(){this.bindHandlers()},
// Called when the grid's resources need to be cleaned up
destroy:function(){},/* Coordinates & Cells
	------------------------------------------------------------------------------------------------------------------*/
// Populates the given empty arrays with the y and x coordinates of the cells
buildCoords:function(a,b){},
// Given a cell object, returns the date for that cell
getCellDate:function(a){},
// Given a cell object, returns the element that represents the cell's whole-day
getCellDayEl:function(a){},
// Converts a range with an inclusive `start` and an exclusive `end` into an array of segment objects
rangeToSegs:function(a,b){},/* Handlers
	------------------------------------------------------------------------------------------------------------------*/
// Attach handlers to `this.el`, using bubbling to listen to all ancestors.
// We don't need to undo any of this in a "destroy" method, because the view will simply remove `this.el` from the
// DOM and jQuery will be smart enough to garbage collect the handlers.
bindHandlers:function(){var b=this;this.el.on("mousedown",function(c){a(c.target).is(".fc-event-container *, .fc-more")||a(c.target).closest(".fc-popover").length||b.dayMousedown(c)}),this.bindSegHandlers()},
// Process a mousedown on an element that represents a day. For day clicking and selecting.
dayMousedown:function(a){var b,c,d,e=this,f=this.view,g=f.calendar,h=f.opt("selectable"),i=null,j=new $(this.coordMap,{
//distance: 5, // needs more work if we want dayClick to fire correctly
scroll:f.opt("dragScroll"),dragStart:function(){f.unselect()},cellOver:function(a,f){j.origDate&&(d=e.getCellDayEl(a),i=[f,j.origDate].sort(I),b=i[0],c=i[1].clone().add(e.cellDuration),h&&(g.isSelectionAllowedInRange(b,c)?e.renderSelection(b,c):(i=null,n())))},cellOut:function(a,b){i=null,e.destroySelection(),o()},listenStop:function(a){i&&(// started and ended on a cell?
i[0].isSame(i[1])&&f.trigger("dayClick",d[0],b,a),h&&
// the selection will already have been rendered. just report it
f.reportSelection(b,c,a)),o()}});j.mousedown(a)},/* Event Dragging
	------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of a event being dragged over the given date(s).
// `end` can be null, as well as `seg`. See View's documentation on renderDrag for more info.
// A returned value of `true` signals that a mock "helper" event has been rendered.
renderDrag:function(a,b,c){},
// Unrenders a visual indication of an event being dragged
destroyDrag:function(){},/* Event Resizing
	------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of an event being resized.
// `start` and `end` are the updated dates of the event. `seg` is the original segment object involved in the drag.
renderResize:function(a,b,c){},
// Unrenders a visual indication of an event being resized.
destroyResize:function(){},/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/
// Renders a mock event over the given date(s).
// `end` can be null, in which case the mock event that is rendered will have a null end time.
// `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.
renderRangeHelper:function(a,b,c){var d,e=this.view;
// compute the end time if forced to do so (this is what EventManager does)
!b&&e.opt("forceEventDuration")&&(b=e.calendar.getDefaultEventEnd(!a.hasTime(),a)),d=c?C(c.event):{},d.start=a,d.end=b,d.allDay=!(a.hasTime()||b&&b.hasTime()),d.className=(d.className||[]).concat("fc-helper"),c||(d.editable=!1),this.renderHelper(d,c)},
// Renders a mock event
renderHelper:function(a,b){},
// Unrenders a mock event
destroyHelper:function(){},/* Selection
	------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.
renderSelection:function(a,b){this.renderHighlight(a,b)},
// Unrenders any visual indications of a selection. Will unrender a highlight by default.
destroySelection:function(){this.destroyHighlight()},/* Highlight
	------------------------------------------------------------------------------------------------------------------*/
// Renders an emphasis on the given date range. `start` is inclusive. `end` is exclusive.
renderHighlight:function(a,b){this.renderFill("highlight",this.rangeToSegs(a,b))},
// Unrenders the emphasis on a date range
destroyHighlight:function(){this.destroyFill("highlight")},
// Generates an array of classNames for rendering the highlight. Used by the fill system.
highlightSegClasses:function(){return["fc-highlight"]},/* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/
// Renders a set of rectangles over the given segments of time.
// Returns a subset of segs, the segs that were actually rendered.
// Responsible for populating this.elsByFill
renderFill:function(a,b){},
// Unrenders a specific type of fill that is currently rendered on the grid
destroyFill:function(a){var b=this.elsByFill[a];b&&(b.remove(),delete this.elsByFill[a])},
// Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
// Only returns segments that successfully rendered.
// To be harnessed by renderFill (implemented by subclasses).
// Analagous to renderFgSegEls.
renderFillSegEls:function(b,c){var d,e=this,f=this[b+"SegEl"],g="",h=[];if(c.length){
// build a large concatenation of segment HTML
for(d=0;d<c.length;d++)g+=this.fillSegHtml(b,c[d]);
// Grab individual elements from the combined HTML string. Use each as the default rendering.
// Then, compute the 'el' for each segment.
a(g).each(function(b,d){var g=c[b],i=a(d);
// allow custom filter methods per-type
f&&(i=f.call(e,g,i)),i&&(i=a(i),i.is(e.fillSegTag)&&(g.el=i,h.push(g)))})}return h},fillSegTag:"div",// subclasses can override
// Builds the HTML needed for one fill segment. Generic enought o work with different types.
fillSegHtml:function(a,b){var c=this[a+"SegClasses"],d=this[a+"SegStyles"],e=c?c.call(this,b):[],f=d?d.call(this,b):"";// a semi-colon separated CSS property string
return"<"+this.fillSegTag+(e.length?' class="'+e.join(" ")+'"':"")+(f?' style="'+f+'"':"")+" />"},/* Generic rendering utilities for subclasses
	------------------------------------------------------------------------------------------------------------------*/
// Renders a day-of-week header row
headHtml:function(){// leverages RowRenderer
return'<div class="fc-row '+this.view.widgetHeaderClass+'"><table><thead>'+this.rowHtml("head")+"</thead></table></div>"},
// Used by the `headHtml` method, via RowRenderer, for rendering the HTML of a day-of-week header cell
headCellHtml:function(a,b,c){var d=this.view,e=d.calendar,f=d.opt("columnFormat");return'<th class="fc-day-header '+d.widgetHeaderClass+" fc-"+Na[c.day()]+'">'+F(e.formatDate(c,f))+"</th>"},
// Renders the HTML for a single-day background cell
bgCellHtml:function(a,b,c){var d=this.view,e=this.getDayClasses(c);return e.unshift("fc-day",d.widgetContentClass),'<td class="'+e.join(" ")+'" data-date="'+c.format()+'"></td>'},
// Computes HTML classNames for a single-day cell
getDayClasses:function(a){var b=this.view,c=b.calendar.getNow().stripTime(),d=["fc-"+Na[a.day()]];return"month"===b.name&&a.month()!=b.intervalStart.month()&&d.push("fc-other-month"),a.isSame(c,"day")?d.push("fc-today",b.highlightStateClass):c>a?d.push("fc-past"):d.push("fc-future"),d}}),/* Event-rendering and event-interaction methods for the abstract Grid class
----------------------------------------------------------------------------------------------------------------------*/
a.extend(ca.prototype,{mousedOverSeg:null,// the segment object the user's mouse is over. null if over nothing
isDraggingSeg:!1,// is a segment being dragged? boolean
isResizingSeg:!1,// is a segment being resized? boolean
segs:null,// the event segments currently rendered in the grid
// Renders the given events onto the grid
renderEvents:function(a){var b,c,d=this.eventsToSegs(a),e=[],f=[];for(b=0;b<d.length;b++)c=d[b],da(c.event)?e.push(c):f.push(c);e=this.renderBgSegs(e)||e,f=this.renderFgSegs(f)||f,this.segs=e.concat(f)},
// Unrenders all events currently rendered on the grid
destroyEvents:function(){this.triggerSegMouseout(),// trigger an eventMouseout if user's mouse is over an event
this.destroyFgSegs(),this.destroyBgSegs(),this.segs=null},
// Retrieves all rendered segment objects currently rendered on the grid
getSegs:function(){return this.segs||[]},/* Foreground Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/
// Renders foreground event segments onto the grid. May return a subset of segs that were rendered.
renderFgSegs:function(a){},
// Unrenders all currently rendered foreground segments
destroyFgSegs:function(){},
// Renders and assigns an `el` property for each foreground event segment.
// Only returns segments that successfully rendered.
// A utility that subclasses may use.
renderFgSegEls:function(b,c){var d,e=this.view,f="",g=[];if(b.length){// don't build an empty html string
// build a large concatenation of event segment HTML
for(d=0;d<b.length;d++)f+=this.fgSegHtml(b[d],c);
// Grab individual elements from the combined HTML string. Use each as the default rendering.
// Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
a(f).each(function(c,d){var f=b[c],h=e.resolveEventEl(f.event,a(d));h&&(h.data("fc-seg",f),// used by handlers
f.el=h,g.push(f))})}return g},
// Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
fgSegHtml:function(a,b){},/* Background Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/
// Renders the given background event segments onto the grid.
// Returns a subset of the segs that were actually rendered.
renderBgSegs:function(a){return this.renderFill("bgEvent",a)},
// Unrenders all the currently rendered background event segments
destroyBgSegs:function(){this.destroyFill("bgEvent")},
// Renders a background event element, given the default rendering. Called by the fill system.
bgEventSegEl:function(a,b){return this.view.resolveEventEl(a.event,b)},
// Generates an array of classNames to be used for the default rendering of a background event.
// Called by the fill system.
bgEventSegClasses:function(a){var b=a.event,c=b.source||{};return["fc-bgevent"].concat(b.className,c.className||[])},
// Generates a semicolon-separated CSS string to be used for the default rendering of a background event.
// Called by the fill system.
// TODO: consolidate with getEventSkinCss?
bgEventSegStyles:function(a){var b=this.view,c=a.event,d=c.source||{},e=c.color,f=d.color,g=b.opt("eventColor"),h=c.backgroundColor||e||d.backgroundColor||f||b.opt("eventBackgroundColor")||g;return h?"background-color:"+h:""},
// Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.
businessHoursSegClasses:function(a){return["fc-nonbusiness","fc-bgevent"]},/* Handlers
	------------------------------------------------------------------------------------------------------------------*/
// Attaches event-element-related handlers to the container element and leverage bubbling
bindSegHandlers:function(){var b=this,c=this.view;a.each({mouseenter:function(a,c){b.triggerSegMouseover(a,c)},mouseleave:function(a,c){b.triggerSegMouseout(a,c)},click:function(a,b){return c.trigger("eventClick",this,a.event,b)},mousedown:function(d,e){a(e.target).is(".fc-resizer")&&c.isEventResizable(d.event)?b.segResizeMousedown(d,e):c.isEventDraggable(d.event)&&b.segDragMousedown(d,e)}},function(c,d){
// attach the handler to the container element and only listen for real event elements via bubbling
b.el.on(c,".fc-event-container > *",function(c){var e=a(this).data("fc-seg");// grab segment data. put there by View::renderEvents
// only call the handlers if there is not a drag/resize in progress
// grab segment data. put there by View::renderEvents
// only call the handlers if there is not a drag/resize in progress
return!e||b.isDraggingSeg||b.isResizingSeg?void 0:d.call(this,e,c)})})},
// Updates internal state and triggers handlers for when an event element is moused over
triggerSegMouseover:function(a,b){this.mousedOverSeg||(this.mousedOverSeg=a,this.view.trigger("eventMouseover",a.el[0],a.event,b))},
// Updates internal state and triggers handlers for when an event element is moused out.
// Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
triggerSegMouseout:function(a,b){b=b||{},this.mousedOverSeg&&(a=a||this.mousedOverSeg,this.mousedOverSeg=null,this.view.trigger("eventMouseout",a.el[0],a.event,b))},/* Dragging
	------------------------------------------------------------------------------------------------------------------*/
// Called when the user does a mousedown on an event, which might lead to dragging.
// Generic enough to work with any type of Grid.
segDragMousedown:function(a,b){var c,d,e=this,f=this.view,g=f.calendar,h=a.el,i=a.event,j=new aa(a.el,{parentEl:f.el,opacity:f.opt("dragOpacity"),revertDuration:f.opt("dragRevertDuration"),zIndex:2}),k=new $(f.coordMap,{distance:5,scroll:f.opt("dragScroll"),listenStart:function(a){j.hide(),// don't show until we know this is a real drag
j.start(a)},dragStart:function(b){e.triggerSegMouseout(a,b),// ensure a mouseout on the manipulated event has been reported
e.isDraggingSeg=!0,f.hideEvent(i),// hide all event segments. our mouseFollower will take over
f.trigger("eventDragStart",h[0],i,b,{})},cellOver:function(b,h){var l=a.cellDate||k.origDate,m=e.computeDraggedEventDates(a,l,h);c=m.start,d=m.end,g.isEventAllowedInRange(i,c,m.visibleEnd)?f.renderDrag(c,d,a)?j.hide():j.show():(c=null,j.show(),n())},cellOut:function(){c=null,f.destroyDrag(),j.show(),o()},dragStop:function(a){var b=c&&!c.isSame(i.start);
// do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
j.stop(!b,function(){e.isDraggingSeg=!1,f.destroyDrag(),f.showEvent(i),f.trigger("eventDragStop",h[0],i,a,{}),// last argument is jqui dummy
b&&f.eventDrop(h[0],i,c,a)}),o()},listenStop:function(){j.stop()}});k.mousedown(b)},
// Given a segment, the dates where a drag began and ended, calculates the Event Object's new start and end dates.
// Might return a `null` end (even when forceEventDuration is on).
computeDraggedEventDates:function(a,b,c){var d,e,f,g,h,i=this.view,j=a.event,k=j.start,l=i.calendar.getEventEnd(j);// do we need to compute an end?
// if switching from day <-> timed, start should be reset to the dropped date, and the end cleared
// end should be cleared
// compute what the end date will appear to be
return c.hasTime()===b.hasTime()?(d=z(c,b),e=k.clone().add(d),f=null===j.end?null:l.clone().add(d),g=j.allDay):(e=c,f=null,g=!c.hasTime()),h=f||i.calendar.getDefaultEventEnd(g,e),{start:e,end:f,visibleEnd:h}},/* Resizing
	------------------------------------------------------------------------------------------------------------------*/
// Called when the user does a mousedown on an event's resizer, which might lead to resizing.
// Generic enough to work with any type of Grid.
segResizeMousedown:function(a,b){function c(){// resets the rendering to show the original event
e.destroyResize(),f.showEvent(i)}var d,e=this,f=this.view,g=f.calendar,h=a.el,i=a.event,j=i.start,k=f.calendar.getEventEnd(i),l=null;d=new $(this.coordMap,{distance:5,scroll:f.opt("dragScroll"),dragStart:function(b){e.triggerSegMouseout(a,b),// ensure a mouseout on the manipulated event has been reported
e.isResizingSeg=!0,f.trigger("eventResizeStart",h[0],i,b,{})},cellOver:function(b,d){
// compute the new end. don't allow it to go before the event's start
d.isBefore(j)&&(// allows comparing ambig to non-ambig
d=j),l=d.clone().add(e.cellDuration),g.isEventAllowedInRange(i,j,l)?l.isSame(k)?(l=null,c()):(e.renderResize(j,l,a),f.hideEvent(i)):(l=null,c(),n())},cellOut:function(){l=null,c(),o()},dragStop:function(a){e.isResizingSeg=!1,c(),o(),f.trigger("eventResizeStop",h[0],i,a,{}),// last argument is jqui dummy
l&&f.eventResize(h[0],i,l,a)}}),d.mousedown(b)},/* Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/
// Generic utility for generating the HTML classNames for an event segment's element
getSegClasses:function(a,b,c){var d=a.event,e=["fc-event",a.isStart?"fc-start":"fc-not-start",a.isEnd?"fc-end":"fc-not-end"].concat(d.className,d.source?d.source.className:[]);return b&&e.push("fc-draggable"),c&&e.push("fc-resizable"),e},
// Utility for generating a CSS string with all the event skin-related properties
getEventSkinCss:function(a){var b=this.view,c=a.source||{},d=a.color,e=c.color,f=b.opt("eventColor"),g=a.backgroundColor||d||c.backgroundColor||e||b.opt("eventBackgroundColor")||f,h=a.borderColor||d||c.borderColor||e||b.opt("eventBorderColor")||f,i=a.textColor||c.textColor||b.opt("eventTextColor"),j=[];return g&&j.push("background-color:"+g),h&&j.push("border-color:"+h),i&&j.push("color:"+i),j.join(";")},/* Converting events -> ranges -> segs
	------------------------------------------------------------------------------------------------------------------*/
// Converts an array of event objects into an array of event segment objects.
// A custom `rangeToSegsFunc` may be given for arbitrarily slicing up events.
eventsToSegs:function(a,b){var c,d=this.eventsToRanges(a),e=[];for(c=0;c<d.length;c++)e.push.apply(e,this.eventRangeToSegs(d[c],b));return e},
// Converts an array of events into an array of "range" objects.
// A "range" object is a plain object with start/end properties denoting the time it covers. Also an event property.
// For "normal" events, this will be identical to the event's start/end, but for "inverse-background" events,
// will create an array of ranges that span the time *not* covered by the given event.
eventsToRanges:function(b){var c=this,d=ga(b),e=[];
// group by ID so that related inverse-background events can be rendered together
return a.each(d,function(a,b){b.length&&e.push.apply(e,ea(b[0])?c.eventsToInverseRanges(b):c.eventsToNormalRanges(b))}),e},
// Converts an array of "normal" events (not inverted rendering) into a parallel array of ranges
eventsToNormalRanges:function(a){var b,c,d,e,f=this.view.calendar,g=[];for(b=0;b<a.length;b++)c=a[b],d=c.start.clone().stripZone(),e=f.getEventEnd(c).stripZone(),g.push({event:c,start:d,end:e,eventStartMS:+d,eventDurationMS:e-d});return g},
// Converts an array of events, with inverse-background rendering, into an array of range objects.
// The range objects will cover all the time NOT covered by the events.
eventsToInverseRanges:function(a){var b,c,d=this.view,e=d.start.clone().stripZone(),f=d.end.clone().stripZone(),g=this.eventsToNormalRanges(a),h=[],i=a[0],j=e;for(
// ranges need to be in order. required for our date-walking algorithm
g.sort(ha),b=0;b<g.length;b++)c=g[b],c.start>j&&h.push({event:i,start:j,end:c.start}),j=c.end;
// add the span of time after the last event (if there is any)
// compare millisecond time (skip any ambig logic)
return f>j&&h.push({event:i,start:j,end:f}),h},
// Slices the given event range into one or more segment objects.
// A `rangeToSegsFunc` custom slicing function can be given.
eventRangeToSegs:function(a,b){var c,d,e;for(c=b?b(a.start,a.end):this.rangeToSegs(a.start,a.end),d=0;d<c.length;d++)e=c[d],e.event=a.event,e.eventStartMS=a.eventStartMS,e.eventDurationMS=a.eventDurationMS;return c}}),ja.prototype=C(ca.prototype),// declare the super-class
a.extend(ja.prototype,{numbersVisible:!1,// should render a row for day/week numbers? manually set by the view
cellDuration:b.duration({days:1}),// required for Grid.event.js. Each cell is always a single day
bottomCoordPadding:0,// hack for extending the hit area for the last row of the coordinate grid
rowEls:null,// set of fake row elements
dayEls:null,// set of whole-day elements comprising the row's background
helperEls:null,// set of cell skeleton elements for rendering the mock event "helper"
// Renders the rows and columns into the component's `this.el`, which should already be assigned.
// isRigid determins whether the individual rows should ignore the contents and be a constant height.
// Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
render:function(b){var c,d=this.view,e="";for(c=0;c<d.rowCnt;c++)e+=this.dayRowHtml(c,b);this.el.html(e),this.rowEls=this.el.find(".fc-row"),this.dayEls=this.el.find(".fc-day"),
// run all the day cells through the dayRender callback
this.dayEls.each(function(b,c){var e=d.cellToDate(Math.floor(b/d.colCnt),b%d.colCnt);d.trigger("dayRender",null,e,a(c))}),ca.prototype.render.call(this)},destroy:function(){this.destroySegPopover()},
// Generates the HTML for a single row. `row` is the row number.
dayRowHtml:function(a,b){var c=this.view,d=["fc-row","fc-week",c.widgetContentClass];// leverages RowRenderer. calls dayCellHtml()
// leverages RowRenderer. View will define render method
return b&&d.push("fc-rigid"),'<div class="'+d.join(" ")+'"><div class="fc-bg"><table>'+this.rowHtml("day",a)+'</table></div><div class="fc-content-skeleton"><table>'+(this.numbersVisible?"<thead>"+this.rowHtml("number",a)+"</thead>":"")+"</table></div></div>"},
// Renders the HTML for a whole-day cell. Will eventually end up in the day-row's background.
// We go through a 'day' row type instead of just doing a 'bg' row type so that the View can do custom rendering
// specifically for whole-day rows, whereas a 'bg' might also be used for other purposes (TimeGrid bg for example).
dayCellHtml:function(a,b,c){return this.bgCellHtml(a,b,c)},/* Coordinates & Cells
	------------------------------------------------------------------------------------------------------------------*/
// Populates the empty `rows` and `cols` arrays with coordinates of the cells. For CoordGrid.
buildCoords:function(b,c){var d,e,f,g=this.view.colCnt;this.dayEls.slice(0,g).each(function(b,g){d=a(g),e=d.offset().left,b&&(f[1]=e),f=[e],c[b]=f}),f[1]=e+d.outerWidth(),this.rowEls.each(function(c,g){d=a(g),e=d.offset().top,c&&(f[1]=e),f=[e],b[c]=f}),f[1]=e+d.outerHeight()+this.bottomCoordPadding},
// Converts a cell to a date
getCellDate:function(a){return this.view.cellToDate(a)},
// Gets the whole-day element associated with the cell
getCellDayEl:function(a){return this.dayEls.eq(a.row*this.view.colCnt+a.col)},
// Converts a range with an inclusive `start` and an exclusive `end` into an array of segment objects
rangeToSegs:function(a,b){return this.view.rangeToSegments(a,b)},/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of an event hovering over the given date(s).
// `end` can be null, as well as `seg`. See View's documentation on renderDrag for more info.
// A returned value of `true` signals that a mock "helper" event has been rendered.
renderDrag:function(a,b,c){var d;
// if a segment from the same calendar but another component is being dragged, render a helper event
// always render a highlight underneath
// if a segment from the same calendar but another component is being dragged, render a helper event
return this.renderHighlight(a,b||this.view.calendar.getDefaultEventEnd(!0,a)),c&&!c.el.closest(this.el).length?(this.renderRangeHelper(a,b,c),d=this.view.opt("dragOpacity"),void 0!==d&&this.helperEls.css("opacity",d),!0):void 0},
// Unrenders any visual indication of a hovering event
destroyDrag:function(){this.destroyHighlight(),this.destroyHelper()},/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of an event being resized
renderResize:function(a,b,c){this.renderHighlight(a,b),this.renderRangeHelper(a,b,c)},
// Unrenders a visual indication of an event being resized
destroyResize:function(){this.destroyHighlight(),this.destroyHelper()},/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/
// Renders a mock "helper" event. `sourceSeg` is the associated internal segment object. It can be null.
renderHelper:function(b,c){var d,e=[],f=this.eventsToSegs([b]);f=this.renderFgSegEls(f),d=this.renderSegRows(f),this.rowEls.each(function(b,f){var g,h=a(f),i=a('<div class="fc-helper-skeleton"><table/></div>');g=c&&c.row===b?c.el.position().top:h.find(".fc-content-skeleton tbody").position().top,i.css("top",g).find("table").append(d[b].tbodyEl),h.append(i),e.push(i[0])}),this.helperEls=a(e)},
// Unrenders any visual indication of a mock helper event
destroyHelper:function(){this.helperEls&&(this.helperEls.remove(),this.helperEls=null)},/* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/
fillSegTag:"td",// override the default tag name
// Renders a set of rectangles over the given segments of days.
// Only returns segments that successfully rendered.
renderFill:function(b,c){var d,e,f,g=[];// assignes `.el` to each seg. returns successfully rendered segs
for(c=this.renderFillSegEls(b,c),d=0;d<c.length;d++)e=c[d],f=this.renderFillRow(b,e),this.rowEls.eq(e.row).append(f),g.push(f[0]);return this.elsByFill[b]=a(g),c},
// Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
renderFillRow:function(b,c){var d,e,f=this.view.colCnt,g=c.leftCol,h=c.rightCol+1;return d=a('<div class="fc-'+b.toLowerCase()+'-skeleton"><table><tr/></table></div>'),e=d.find("tr"),g>0&&e.append('<td colspan="'+g+'"/>'),e.append(c.el.attr("colspan",h-g)),f>h&&e.append('<td colspan="'+(f-h)+'"/>'),this.bookendCells(e,b),d}}),/* Event-rendering methods for the DayGrid class
----------------------------------------------------------------------------------------------------------------------*/
a.extend(ja.prototype,{rowStructs:null,// an array of objects, each holding information about a row's foreground event-rendering
// Unrenders all events currently rendered on the grid
destroyEvents:function(){this.destroySegPopover(),// removes the "more.." events popover
ca.prototype.destroyEvents.apply(this,arguments)},
// Retrieves all rendered segment objects currently rendered on the grid
getSegs:function(){return ca.prototype.getSegs.call(this).concat(this.popoverSegs||[])},
// Renders the given background event segments onto the grid
renderBgSegs:function(b){
// don't render timed background events
var c=a.grep(b,function(a){return a.event.allDay});return ca.prototype.renderBgSegs.call(this,c)},
// Renders the given foreground event segments onto the grid
renderFgSegs:function(b){var c;
// render an `.el` on each seg
// returns a subset of the segs. segs that were actually rendered
// append to each row's content skeleton
return b=this.renderFgSegEls(b),c=this.rowStructs=this.renderSegRows(b),this.rowEls.each(function(b,d){a(d).find(".fc-content-skeleton > table").append(c[b].tbodyEl)}),b},
// Unrenders all currently rendered foreground event segments
destroyFgSegs:function(){for(var a,b=this.rowStructs||[];a=b.pop();)a.tbodyEl.remove();this.rowStructs=null},
// Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
// Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
// PRECONDITION: each segment shoud already have a rendered and assigned `.el`
renderSegRows:function(a){var b,c,d=[];// group into nested arrays
// iterate each row of segment groupings
for(b=this.groupSegRows(a),c=0;c<b.length;c++)d.push(this.renderSegRow(c,b[c]));return d},
// Builds the HTML to be used for the default element for an individual segment
fgSegHtml:function(a,b){var c,d=this.view,e=d.opt("isRTL"),f=a.event,g=d.isEventDraggable(f),h=!b&&f.allDay&&a.isEnd&&d.isEventResizable(f),i=this.getSegClasses(a,g,h),j=this.getEventSkinCss(f),k="";
// Only display a timed events time if it is the starting segment
// we always want one line of height
// put a natural space in between
return i.unshift("fc-day-grid-event"),!f.allDay&&a.isStart&&(k='<span class="fc-time">'+F(d.getEventTimeText(f))+"</span>"),c='<span class="fc-title">'+(F(f.title||"")||"&nbsp;")+"</span>",'<a class="'+i.join(" ")+'"'+(f.url?' href="'+F(f.url)+'"':"")+(j?' style="'+j+'"':"")+'><div class="fc-content">'+(e?c+" "+k:k+" "+c)+"</div>"+(h?'<div class="fc-resizer"/>':"")+"</a>"},
// Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
// the segments. Returns object with a bunch of internal data about how the render was calculated.
renderSegRow:function(b,c){
// populates empty cells from the current column (`col`) to `endCol`
function d(b){for(;b>g;)k=(s[e-1]||[])[g],k?k.attr("rowspan",parseInt(k.attr("rowspan")||1,10)+1):(k=a("<td/>"),h.append(k)),r[e][g]=k,s[e][g]=k,g++}var e,f,g,h,i,j,k,l=this.view,m=l.colCnt,n=this.buildSegLevels(c),o=Math.max(1,n.length),p=a("<tbody/>"),q=[],r=[],s=[];for(e=0;o>e;e++){
// levelCnt might be 1 even though there are no actual levels. protect against this.
// this single empty row is useful for styling.
if(f=n[e],g=0,h=a("<tr/>"),q.push([]),r.push([]),s.push([]),f)for(i=0;i<f.length;i++){for(// iterate through segments in level
j=f[i],d(j.leftCol),
// create a container that occupies or more columns. append the event element.
k=a('<td class="fc-event-container"/>').append(j.el),j.leftCol!=j.rightCol?k.attr("colspan",j.rightCol-j.leftCol+1):// a single-column segment
s[e][g]=k;g<=j.rightCol;)r[e][g]=k,q[e][g]=j,g++;h.append(k)}d(m),// finish off the row
this.bookendCells(h,"eventSkeleton"),p.append(h)}return{// a "rowStruct"
row:b,// the row number
tbodyEl:p,cellMatrix:r,segMatrix:q,segLevels:n,segs:c}},
// Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
buildSegLevels:function(a){var b,c,d,e=[];for(
// Give preference to elements with certain criteria, so they have
// a chance to be closer to the top.
a.sort(ia),b=0;b<a.length;b++){
// loop through levels, starting with the topmost, until the segment doesn't collide with other segments
for(c=a[b],d=0;d<e.length&&ka(c,e[d]);d++);
// `j` now holds the desired subrow index
c.level=d,
// create new level array if needed and append segment
(e[d]||(e[d]=[])).push(c)}
// order segments left-to-right. very important if calendar is RTL
for(d=0;d<e.length;d++)e[d].sort(la);return e},
// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
groupSegRows:function(a){var b,c=this.view,d=[];for(b=0;b<c.rowCnt;b++)d.push([]);for(b=0;b<a.length;b++)d[a[b].row].push(a[b]);return d}}),/* Methods relate to limiting the number events for a given day on a DayGrid
----------------------------------------------------------------------------------------------------------------------*/
// NOTE: all the segs being passed around in here are foreground segs
a.extend(ja.prototype,{segPopover:null,// the Popover that holds events that can't fit in a cell. null when not visible
popoverSegs:null,// an array of segment objects that the segPopover holds. null when not visible
destroySegPopover:function(){this.segPopover&&this.segPopover.hide()},
// Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
// `levelLimit` can be false (don't limit), a number, or true (should be computed).
limitRows:function(a){var b,c,d=this.rowStructs||[];for(b=0;b<d.length;b++)this.unlimitRow(b),c=a?"number"==typeof a?a:this.computeRowLevelLimit(b):!1,c!==!1&&this.limitRow(b,c)},
// Computes the number of levels a row will accomodate without going outside its bounds.
// Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
// `row` is the row number.
computeRowLevelLimit:function(a){var b,c,d=this.rowEls.eq(a),e=d.height(),f=this.rowStructs[a].tbodyEl.children();
// Reveal one level <tr> at a time and stop when we find one out of bounds
for(b=0;b<f.length;b++)// get and reveal
if(c=f.eq(b).removeClass("fc-limited"),c.position().top+c.outerHeight()>e)return b;return!1},
// Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
// `row` is the row number.
// `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
limitRow:function(b,c){
// Iterates through empty level cells and places "more" links inside if need be
function d(d){// goes from current `col` to `endCol`
for(;d>y;)e={row:b,col:y},k=u.getCellSegs(e,c),k.length&&(n=g[c-1][y],t=u.renderMoreLink(e,k),s=a("<div/>").append(t),n.append(s),x.push(s[0])),y++}var e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u=this,v=this.view,w=this.rowStructs[b],x=[],y=0;if(c&&c<w.segLevels.length){// hide elements and get a simple DOM-nodes array
// iterate though segments in the last allowable level
for(f=w.segLevels[c-1],g=w.cellMatrix,h=w.tbodyEl.children().slice(c).addClass("fc-limited").get(),i=0;i<f.length;i++){for(j=f[i],d(j.leftCol),// process empty cells before the segment
// determine *all* segments below `seg` that occupy the same columns
m=[],l=0;y<=j.rightCol;)e={row:b,col:y},k=this.getCellSegs(e,c),m.push(k),l+=k.length,y++;if(l){
// make a replacement <td> for each column the segment occupies. will be one for each colspan
for(n=g[c-1][j.leftCol],o=n.attr("rowspan")||1,p=[],q=0;q<m.length;q++)r=a('<td class="fc-more-cell"/>').attr("rowspan",o),k=m[q],e={row:b,col:j.leftCol+q},t=this.renderMoreLink(e,[j].concat(k)),s=a("<div/>").append(t),r.append(s),p.push(r[0]),x.push(r[0]);n.addClass("fc-limited").after(a(p)),// hide original <td> and inject replacements
h.push(n[0])}}d(v.colCnt),// finish off the level
w.moreEls=a(x),// for easy undoing later
w.limitedEls=a(h)}},
// Reveals all levels and removes all "more"-related elements for a grid's row.
// `row` is a row number.
unlimitRow:function(a){var b=this.rowStructs[a];b.moreEls&&(b.moreEls.remove(),b.moreEls=null),b.limitedEls&&(b.limitedEls.removeClass("fc-limited"),b.limitedEls=null)},
// Renders an <a> element that represents hidden event element for a cell.
// Responsible for attaching click handler as well.
renderMoreLink:function(b,c){var d=this,e=this.view;return a('<a class="fc-more"/>').text(this.getMoreLinkText(c.length)).on("click",function(f){var g=e.opt("eventLimitClick"),h=e.cellToDate(b),i=a(this),j=d.getCellDayEl(b),k=d.getCellSegs(b),l=d.resliceDaySegs(k,h),m=d.resliceDaySegs(c,h);"function"==typeof g&&(
// the returned value can be an atomic option
g=e.trigger("eventLimitClick",null,{date:h,dayEl:j,moreEl:i,segs:l,hiddenSegs:m},f)),"popover"===g?d.showSegPopover(h,b,i,l):"string"==typeof g&&// a view name
e.calendar.zoomTo(h,g)})},
// Reveals the popover that displays all events within a cell
showSegPopover:function(a,b,c,d){var e,f,g=this,h=this.view,i=c.parent();e=1==h.rowCnt?this.view.el:this.rowEls.eq(b.row),f={className:"fc-more-popover",content:this.renderSegPopoverContent(a,d),parentEl:this.el,top:e.offset().top,autoHide:!0,viewportConstrain:h.opt("popoverViewportConstrain"),hide:function(){g.segPopover.destroy(),g.segPopover=null,g.popoverSegs=null}},h.opt("isRTL")?f.right=i.offset().left+i.outerWidth()+1:f.left=i.offset().left-1,this.segPopover=new X(f),this.segPopover.show()},
// Builds the inner DOM contents of the segment popover
renderSegPopoverContent:function(b,c){var d,e=this.view,f=e.opt("theme"),g=b.format(e.opt("dayPopoverFormat")),h=a('<div class="fc-header '+e.widgetHeaderClass+'"><span class="fc-close '+(f?"ui-icon ui-icon-closethick":"fc-icon fc-icon-x")+'"></span><span class="fc-title">'+F(g)+'</span><div class="fc-clear"/></div><div class="fc-body '+e.widgetContentClass+'"><div class="fc-event-container"></div></div>'),i=h.find(".fc-event-container");for(c=this.renderFgSegEls(c,!0),this.popoverSegs=c,d=0;d<c.length;d++)
// because segments in the popover are not part of a grid coordinate system, provide a hint to any
// grids that want to do drag-n-drop about which cell it came from
c[d].cellDate=b,i.append(c[d].el);return h},
// Given the events within an array of segment objects, reslice them to be in a single day
resliceDaySegs:function(b,c){
// build an array of the original events
var d=a.map(b,function(a){return a.event}),e=c.clone().stripTime(),f=e.clone().add(1,"days");
// slice the events with a custom slicing function
return this.eventsToSegs(d,function(a,b){var c=x(a,b,e,f);// if no intersection, undefined
return c?[c]:[]})},
// Generates the text that should be inside a "more" link, given the number of events it represents
getMoreLinkText:function(a){var b=this.view,c=b.opt("eventLimitText");return"function"==typeof c?c(a):"+"+a+" "+c},
// Returns segments within a given cell.
// If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
getCellSegs:function(a,b){for(var c,d=this.rowStructs[a.row].segMatrix,e=b||0,f=[];e<d.length;)c=d[e][a.col],c&&f.push(c),e++;return f}}),ma.prototype=C(ca.prototype),// define the super-class
a.extend(ma.prototype,{slotDuration:null,// duration of a "slot", a distinct time segment on given day, visualized by lines
snapDuration:null,// granularity of time for dragging and selecting
minTime:null,// Duration object that denotes the first visible time of any given day
maxTime:null,// Duration object that denotes the exclusive visible end time of any given day
dayEls:null,// cells elements in the day-row background
slatEls:null,// elements running horizontally across all columns
slatTops:null,// an array of top positions, relative to the container. last item holds bottom of last slot
helperEl:null,// cell skeleton element for rendering the mock event "helper"
businessHourSegs:null,
// Renders the time grid into `this.el`, which should already be assigned.
// Relies on the view's colCnt. In the future, this component should probably be self-sufficient.
render:function(){this.processOptions(),this.el.html(this.renderHtml()),this.dayEls=this.el.find(".fc-day"),this.slatEls=this.el.find(".fc-slats tr"),this.computeSlatTops(),this.renderBusinessHours(),ca.prototype.render.call(this)},renderBusinessHours:function(){var a=this.view.calendar.getBusinessHoursEvents();this.businessHourSegs=this.renderFill("businessHours",this.eventsToSegs(a),"bgevent")},
// Renders the basic HTML skeleton for the grid
renderHtml:function(){// leverages RowRenderer, which will call slotBgCellHtml
return'<div class="fc-bg"><table>'+this.rowHtml("slotBg")+'</table></div><div class="fc-slats"><table>'+this.slatRowHtml()+"</table></div>"},
// Renders the HTML for a vertical background cell behind the slots.
// This method is distinct from 'bg' because we wanted a new `rowType` so the View could customize the rendering.
slotBgCellHtml:function(a,b,c){return this.bgCellHtml(a,b,c)},
// Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
slatRowHtml:function(){
// Calculate the time for each slot
for(var a,c,d,e=this.view,f=e.calendar,g=e.opt("isRTL"),h="",i=this.slotDuration.asMinutes()%15===0,j=b.duration(+this.minTime);j<this.maxTime;)a=e.start.clone().time(j),c=a.minutes(),d='<td class="fc-axis fc-time '+e.widgetContentClass+'" '+e.axisStyleAttr()+">"+(i&&c?"":"<span>"+F(f.formatDate(a,e.opt("axisFormat")))+"</span>")+"</td>",h+="<tr "+(c?'class="fc-minor"':"")+">"+(g?"":d)+'<td class="'+e.widgetContentClass+'"/>'+(g?d:"")+"</tr>",j.add(this.slotDuration);return h},
// Parses various options into properties of this object
processOptions:function(){var a=this.view,c=a.opt("slotDuration"),d=a.opt("snapDuration");c=b.duration(c),d=d?b.duration(d):c,this.slotDuration=c,this.snapDuration=d,this.cellDuration=d,this.minTime=b.duration(a.opt("minTime")),this.maxTime=b.duration(a.opt("maxTime"))},
// Slices up a date range into a segment for each column
rangeToSegs:function(a,b){var c,d,e,f,g,h=this.view,i=[];for(a=a.clone().stripZone(),b=b.clone().stripZone(),d=0;d<h.colCnt;d++)e=h.cellToDate(0,d),f=e.clone().time(this.minTime),g=e.clone().time(this.maxTime),c=x(a,b,f,g),c&&(c.col=d,i.push(c));return i},/* Coordinates
	------------------------------------------------------------------------------------------------------------------*/
// Called when there is a window resize/zoom and we need to recalculate coordinates for the grid
resize:function(){this.computeSlatTops(),this.updateSegVerticals()},
// Populates the given empty `rows` and `cols` arrays with offset positions of the "snap" cells.
// "Snap" cells are different the slots because they might have finer granularity.
buildCoords:function(c,d){var e,f,g=this.view.colCnt,h=this.el.offset().top,i=b.duration(+this.minTime),j=null;for(this.dayEls.slice(0,g).each(function(b,c){e=a(c),f=e.offset().left,j&&(j[1]=f),j=[f],d[b]=j}),j[1]=f+e.outerWidth(),j=null;i<this.maxTime;)f=h+this.computeTimeTop(i),j&&(j[1]=f),j=[f],c.push(j),i.add(this.snapDuration);j[1]=h+this.computeTimeTop(i)},
// Gets the datetime for the given slot cell
getCellDate:function(a){var b=this.view,c=b.calendar;// since we are adding a time, it needs to be in the calendar's timezone
return c.rezoneDate(b.cellToDate(0,a.col).time(this.minTime+this.snapDuration*a.row))},
// Gets the element that represents the whole-day the cell resides on
getCellDayEl:function(a){return this.dayEls.eq(a.col)},
// Computes the top coordinate, relative to the bounds of the grid, of the given date.
// A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
computeDateTop:function(a,c){return this.computeTimeTop(b.duration(a.clone().stripZone()-c.clone().stripTime()))},
// Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
computeTimeTop:function(a){var b,c,d,e,f=(a-this.minTime)/this.slotDuration;return f=Math.max(0,f),f=Math.min(this.slatEls.length,f),b=Math.floor(f),c=f-b,d=this.slatTops[b],c?(e=this.slatTops[b+1],d+(e-d)*c):d},
// Queries each `slatEl` for its position relative to the grid's container and stores it in `slatTops`.
// Includes the the bottom of the last slat as the last item in the array.
computeSlatTops:function(){var b,c=[];this.slatEls.each(function(d,e){b=a(e).position().top,c.push(b)}),c.push(b+this.slatEls.last().outerHeight()),// bottom of the last slat
this.slatTops=c},/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of an event being dragged over the specified date(s).
// `end` and `seg` can be null. See View's documentation on renderDrag for more info.
renderDrag:function(a,b,c){var d;// if there is event information for this drag, render a helper event
// otherwise, just render a highlight
return c?(this.renderRangeHelper(a,b,c),d=this.view.opt("dragOpacity"),void 0!==d&&this.helperEl.css("opacity",d),!0):void this.renderHighlight(a,b||this.view.calendar.getDefaultEventEnd(!1,a))},
// Unrenders any visual indication of an event being dragged
destroyDrag:function(){this.destroyHelper(),this.destroyHighlight()},/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of an event being resized
renderResize:function(a,b,c){this.renderRangeHelper(a,b,c)},
// Unrenders any visual indication of an event being resized
destroyResize:function(){this.destroyHelper()},/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/
// Renders a mock "helper" event. `sourceSeg` is the original segment object and might be null (an external drag)
renderHelper:function(b,c){var d,e,f,g,h=this.eventsToSegs([b]);
// Try to make the segment that is in the same row as sourceSeg look the same
for(h=this.renderFgSegEls(h),d=this.renderSegTable(h),e=0;e<h.length;e++)f=h[e],c&&c.col===f.col&&(g=c.el,f.el.css({left:g.css("left"),right:g.css("right"),"margin-left":g.css("margin-left"),"margin-right":g.css("margin-right")}));this.helperEl=a('<div class="fc-helper-skeleton"/>').append(d).appendTo(this.el)},
// Unrenders any mock helper event
destroyHelper:function(){this.helperEl&&(this.helperEl.remove(),this.helperEl=null)},/* Selection
	------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
renderSelection:function(a,b){this.view.opt("selectHelper")?// this setting signals that a mock helper event should be rendered
this.renderRangeHelper(a,b):this.renderHighlight(a,b)},
// Unrenders any visual indication of a selection
destroySelection:function(){this.destroyHelper(),this.destroyHighlight()},/* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/
// Renders a set of rectangles over the given time segments.
// Only returns segments that successfully rendered.
renderFill:function(b,c,d){var e,f,g,h,i,j,k,l,m,n,o=this.view;if(c.length){for(c=this.renderFillSegEls(b,c),e=this.groupSegCols(c),d=d||b.toLowerCase(),f=a('<div class="fc-'+d+'-skeleton"><table><tr/></table></div>'),g=f.find("tr"),h=0;h<e.length;h++)if(i=e[h],j=a("<td/>").appendTo(g),i.length)for(k=a('<div class="fc-'+d+'-container"/>').appendTo(j),l=o.cellToDate(0,h),m=0;m<i.length;m++)n=i[m],k.append(n.el.css({top:this.computeDateTop(n.start,l),bottom:-this.computeDateTop(n.end,l)}));this.bookendCells(g,b),this.el.append(f),this.elsByFill[b]=f}return c}}),/* Event-rendering methods for the TimeGrid class
----------------------------------------------------------------------------------------------------------------------*/
a.extend(ma.prototype,{eventSkeletonEl:null,// has cells with event-containers, which contain absolutely positioned event elements
// Renders the given foreground event segments onto the grid
renderFgSegs:function(b){// returns a subset of the segs. segs that were actually rendered
return b=this.renderFgSegEls(b),this.el.append(this.eventSkeletonEl=a('<div class="fc-content-skeleton"/>').append(this.renderSegTable(b))),b},
// Unrenders all currently rendered foreground event segments
destroyFgSegs:function(a){this.eventSkeletonEl&&(this.eventSkeletonEl.remove(),this.eventSkeletonEl=null)},
// Renders and returns the <table> portion of the event-skeleton.
// Returns an object with properties 'tbodyEl' and 'segs'.
renderSegTable:function(b){var c,d,e,f,g,h,i=a("<table><tr/></table>"),j=i.find("tr");// compute and assign top/bottom
for(c=this.groupSegCols(b),this.computeSegVerticals(b),f=0;f<c.length;f++){
// assign positioning CSS and insert into container
for(g=c[f],na(g),h=a('<div class="fc-event-container"/>'),d=0;d<g.length;d++)e=g[d],e.el.css(this.generateSegPositionCss(e)),e.bottom-e.top<30&&e.el.addClass("fc-short"),h.append(e.el);j.append(a("<td/>").append(h))}return this.bookendCells(j,"eventSkeleton"),i},
// Refreshes the CSS top/bottom coordinates for each segment element. Probably after a window resize/zoom.
// Repositions business hours segs too, so not just for events. Maybe shouldn't be here.
updateSegVerticals:function(){var a,b=(this.segs||[]).concat(this.businessHourSegs||[]);for(this.computeSegVerticals(b),a=0;a<b.length;a++)b[a].el.css(this.generateSegVerticalCss(b[a]))},
// For each segment in an array, computes and assigns its top and bottom properties
computeSegVerticals:function(a){var b,c;for(b=0;b<a.length;b++)c=a[b],c.top=this.computeDateTop(c.start,c.start),c.bottom=this.computeDateTop(c.end,c.start)},
// Renders the HTML for a single event segment's default rendering
fgSegHtml:function(a,b){var c,d,e,f=this.view,g=a.event,h=f.isEventDraggable(g),i=!b&&a.isEnd&&f.isEventResizable(g),j=this.getSegClasses(a,h,i),k=this.getEventSkinCss(g);// just the start time text
// if the event appears to span more than one day...
// Don't display time text on segments that run entirely through a day.
// That would appear as midnight-midnight and would look dumb.
// Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
// Display the normal time text for the *event's* times
return j.unshift("fc-time-grid-event"),f.isMultiDayEvent(g)?(a.isStart||a.isEnd)&&(c=f.getEventTimeText(a.start,a.end),d=f.getEventTimeText(a.start,a.end,"LT"),e=f.getEventTimeText(a.start,null)):(c=f.getEventTimeText(g),d=f.getEventTimeText(g,"LT"),e=f.getEventTimeText(g.start,null)),'<a class="'+j.join(" ")+'"'+(g.url?' href="'+F(g.url)+'"':"")+(k?' style="'+k+'"':"")+'><div class="fc-content">'+(c?'<div class="fc-time" data-start="'+F(e)+'" data-full="'+F(d)+'"><span>'+F(c)+"</span></div>":"")+(g.title?'<div class="fc-title">'+F(g.title)+"</div>":"")+'</div><div class="fc-bg"/>'+(i?'<div class="fc-resizer"/>':"")+"</a>"},
// Generates an object with CSS properties/values that should be applied to an event segment element.
// Contains important positioning-related properties that should be applied to any event element, customized or not.
generateSegPositionCss:function(a){var b,c,d=this.view,e=d.opt("isRTL"),f=d.opt("slotEventOverlap"),g=a.backwardCoord,h=a.forwardCoord,i=this.generateSegVerticalCss(a);// amount of space from right edge, a fraction of the total width
// double the width, but don't go beyond the maximum forward coordinate (1.0)
// convert from 0-base to 1-based
// add padding to the edge so that forward stacked events don't cover the resizer's icon
return f&&(h=Math.min(1,g+2*(h-g))),e?(b=1-h,c=g):(b=g,c=1-h),i.zIndex=a.level+1,i.left=100*b+"%",i.right=100*c+"%",f&&a.forwardPressure&&(i[e?"marginLeft":"marginRight"]=20),i},
// Generates an object with CSS properties for the top/bottom coordinates of a segment element
generateSegVerticalCss:function(a){return{top:a.top,bottom:-a.bottom}},
// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
groupSegCols:function(a){var b,c=this.view,d=[];for(b=0;b<c.colCnt;b++)d.push([]);for(b=0;b<a.length;b++)d[a[b].col].push(a[b]);return d}}),/* An abstract class from which other views inherit from
----------------------------------------------------------------------------------------------------------------------*/
// Newer methods should be written as prototype methods, not in the monster `View` function at the bottom.
va.prototype={calendar:null,// owner Calendar object
coordMap:null,// a CoordMap object for converting pixel regions to dates
el:null,// the view's containing element. set by Calendar
// important Moments
start:null,// the date of the very first cell
end:null,// the date after the very last cell
intervalStart:null,// the start of the interval of time the view represents (1st of month for month view)
intervalEnd:null,// the exclusive end of the interval of time the view represents
// used for cell-to-date and date-to-cell calculations
rowCnt:null,// # of weeks
colCnt:null,// # of days displayed in a week
isSelected:!1,// boolean whether cells are user-selected or not
// subclasses can optionally use a scroll container
scrollerEl:null,// the element that will most likely scroll when content is too tall
scrollTop:null,// cached vertical scroll value
// classNames styled by jqui themes
widgetHeaderClass:null,widgetContentClass:null,highlightStateClass:null,
// document handlers, bound to `this` object
documentMousedownProxy:null,documentDragStartProxy:null,
// Serves as a "constructor" to suppliment the monster `View` constructor below
init:function(){var b=this.opt("theme")?"ui":"fc";this.widgetHeaderClass=b+"-widget-header",this.widgetContentClass=b+"-widget-content",this.highlightStateClass=b+"-state-highlight",
// save references to `this`-bound handlers
this.documentMousedownProxy=a.proxy(this,"documentMousedown"),this.documentDragStartProxy=a.proxy(this,"documentDragStart")},
// Renders the view inside an already-defined `this.el`.
// Subclasses should override this and then call the super method afterwards.
render:function(){this.updateSize(),this.trigger("viewRender",this,this,this.el),
// attach handlers to document. do it here to allow for destroy/rerender
a(document).on("mousedown",this.documentMousedownProxy).on("dragstart",this.documentDragStartProxy)},
// Clears all view rendering, event elements, and unregisters handlers
destroy:function(){this.unselect(),this.trigger("viewDestroy",this,this,this.el),this.destroyEvents(),this.el.empty(),// removes inner contents but leaves the element intact
a(document).off("mousedown",this.documentMousedownProxy).off("dragstart",this.documentDragStartProxy)},
// Used to determine what happens when the users clicks next/prev. Given -1 for prev, 1 for next.
// Should apply the delta to `date` (a Moment) and return it.
incrementDate:function(a,b){},/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/
// Refreshes anything dependant upon sizing of the container element of the grid
updateSize:function(a){a&&this.recordScroll(),this.updateHeight(),this.updateWidth()},
// Refreshes the horizontal dimensions of the calendar
updateWidth:function(){},
// Refreshes the vertical dimensions of the calendar
updateHeight:function(){var a=this.calendar;// we poll the calendar for height information
this.setHeight(a.getSuggestedViewHeight(),a.isHeightAuto())},
// Updates the vertical dimensions of the calendar to the specified height.
// if `isAuto` is set to true, height becomes merely a suggestion and the view should use its "natural" height.
setHeight:function(a,b){},
// Given the total height of the view, return the number of pixels that should be used for the scroller.
// Utility for subclasses.
computeScrollerHeight:function(a){var b,c=this.el.add(this.scrollerEl);// undo hack
// cumulative height of everything that is not the scrollerEl in the view (header+borders)
// fuckin IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
// grab the dimensions
return c.css({position:"relative",// cause a reflow, which will force fresh dimension recalculation
left:-1}),b=this.el.outerHeight()-this.scrollerEl.height(),c.css({position:"",left:""}),a-b},
// Called for remembering the current scroll value of the scroller.
// Should be called before there is a destructive operation (like removing DOM elements) that might inadvertently
// change the scroll of the container.
recordScroll:function(){this.scrollerEl&&(this.scrollTop=this.scrollerEl.scrollTop())},
// Set the scroll value of the scroller to the previously recorded value.
// Should be called after we know the view's dimensions have been restored following some type of destructive
// operation (like temporarily removing DOM elements).
restoreScroll:function(){null!==this.scrollTop&&this.scrollerEl.scrollTop(this.scrollTop)},/* Events
	------------------------------------------------------------------------------------------------------------------*/
// Renders the events onto the view.
// Should be overriden by subclasses. Subclasses should call the super-method afterwards.
renderEvents:function(a){this.segEach(function(a){this.trigger("eventAfterRender",a.event,a.event,a.el)}),this.trigger("eventAfterAllRender")},
// Removes event elements from the view.
// Should be overridden by subclasses. Should call this super-method FIRST, then subclass DOM destruction.
destroyEvents:function(){this.segEach(function(a){this.trigger("eventDestroy",a.event,a.event,a.el)})},
// Given an event and the default element used for rendering, returns the element that should actually be used.
// Basically runs events and elements through the eventRender hook.
resolveEventEl:function(b,c){var d=this.trigger("eventRender",b,b,c);// means don't render at all
return d===!1?c=null:d&&d!==!0&&(c=a(d)),c},
// Hides all rendered event segments linked to the given event
showEvent:function(a){this.segEach(function(a){a.el.css("visibility","")},a)},
// Shows all rendered event segments linked to the given event
hideEvent:function(a){this.segEach(function(a){a.el.css("visibility","hidden")},a)},
// Iterates through event segments. Goes through all by default.
// If the optional `event` argument is specified, only iterates through segments linked to that event.
// The `this` value of the callback function will be the view.
segEach:function(a,b){var c,d=this.getSegs();for(c=0;c<d.length;c++)b&&d[c].event._id!==b._id||a.call(this,d[c])},
// Retrieves all the rendered segment objects for the view
getSegs:function(){},/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of an event hovering over the specified date.
// `end` is a Moment and might be null.
// `seg` might be null. if specified, it is the segment object of the event being dragged.
//       otherwise, an external event from outside the calendar is being dragged.
renderDrag:function(a,b,c){},
// Unrenders a visual indication of event hovering
destroyDrag:function(){},
// Handler for accepting externally dragged events being dropped in the view.
// Gets called when jqui's 'dragstart' is fired.
documentDragStart:function(b,c){var d,e,f,g,h,i=this,j=this.calendar,k=null,l=null,m=null;this.opt("droppable")&&(d=a(b.target),e=this.opt("dropAccept"),(a.isFunction(e)?e.call(d[0],d):d.is(e))&&(f=wa(d),g=f.eventProps,h=new $(this.coordMap,{cellOver:function(b,c){k=c,l=f.duration?k.clone().add(f.duration):null,m=l||j.getDefaultEventEnd(!k.hasTime(),k),g&&a.extend(g,{start:k,end:l}),j.isExternalDragAllowedInRange(k,m,g)?i.renderDrag(k,m):(k=null,n())},cellOut:function(){k=null,i.destroyDrag(),o()}}),a(document).one("dragstop",function(a,b){var c;i.destroyDrag(),o(),k&&(f.startTime&&!k.hasTime()&&k.time(f.startTime),i.trigger("drop",d[0],k,a,b),g&&(c=j.renderEvent(g,f.stick),i.trigger("eventReceive",null,c[0])))}),h.startDrag(b)))},/* Selection
	------------------------------------------------------------------------------------------------------------------*/
// Selects a date range on the view. `start` and `end` are both Moments.
// `ev` is the native mouse event that begin the interaction.
select:function(a,b,c){this.unselect(c),this.renderSelection(a,b),this.reportSelection(a,b,c)},
// Renders a visual indication of the selection
renderSelection:function(a,b){},
// Called when a new selection is made. Updates internal state and triggers handlers.
reportSelection:function(a,b,c){this.isSelected=!0,this.trigger("select",null,a,b,c)},
// Undoes a selection. updates in the internal state and triggers handlers.
// `ev` is the native mouse event that began the interaction.
unselect:function(a){this.isSelected&&(this.isSelected=!1,this.destroySelection(),this.trigger("unselect",null,a))},
// Unrenders a visual indication of selection
destroySelection:function(){},
// Handler for unselecting when the user clicks something and the 'unselectAuto' setting is on
documentMousedown:function(b){var c;
// is there a selection, and has the user made a proper left click?
this.isSelected&&this.opt("unselectAuto")&&w(b)&&(c=this.opt("unselectCancel"),c&&a(b.target).closest(c).length||this.unselect(b))}},/* Utils
----------------------------------------------------------------------------------------------------------------------*/
// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.
Ja.dataAttrPrefix="",xa.prototype=C(va.prototype),// define the super-class
a.extend(xa.prototype,{dayGrid:null,// the main subcomponent that does most of the heavy lifting
dayNumbersVisible:!1,// display day numbers on each day cell?
weekNumbersVisible:!1,// display week numbers along the side?
weekNumberWidth:null,// width of all the week-number cells running down the side
headRowEl:null,// the fake row element of the day-of-week header
// Renders the view into `this.el`, which should already be assigned.
// rowCnt, colCnt, and dayNumbersVisible have been calculated by a subclass and passed here.
render:function(a,b,c){
// needed for cell-to-date and date-to-cell calculations in View
this.rowCnt=a,this.colCnt=b,this.dayNumbersVisible=c,this.weekNumbersVisible=this.opt("weekNumbers"),this.dayGrid.numbersVisible=this.dayNumbersVisible||this.weekNumbersVisible,this.el.addClass("fc-basic-view").html(this.renderHtml()),this.headRowEl=this.el.find("thead .fc-row"),this.scrollerEl=this.el.find(".fc-day-grid-container"),this.dayGrid.coordMap.containerEl=this.scrollerEl,// constrain clicks/etc to the dimensions of the scroller
this.dayGrid.el=this.el.find(".fc-day-grid"),this.dayGrid.render(this.hasRigidRows()),va.prototype.render.call(this)},
// Make subcomponents ready for cleanup
destroy:function(){this.dayGrid.destroy(),va.prototype.destroy.call(this)},
// Builds the HTML skeleton for the view.
// The day-grid component will render inside of a container defined by this HTML.
renderHtml:function(){// render the day-of-week headers
return'<table><thead><tr><td class="'+this.widgetHeaderClass+'">'+this.dayGrid.headHtml()+'</td></tr></thead><tbody><tr><td class="'+this.widgetContentClass+'"><div class="fc-day-grid-container"><div class="fc-day-grid"/></div></td></tr></tbody></table>'},
// Generates the HTML that will go before the day-of week header cells.
// Queried by the DayGrid subcomponent when generating rows. Ordering depends on isRTL.
headIntroHtml:function(){// needed for matchCellWidths
return this.weekNumbersVisible?'<th class="fc-week-number '+this.widgetHeaderClass+'" '+this.weekNumberStyleAttr()+"><span>"+F(this.opt("weekNumberTitle"))+"</span></th>":void 0},
// Generates the HTML that will go before content-skeleton cells that display the day/week numbers.
// Queried by the DayGrid subcomponent. Ordering depends on isRTL.
numberIntroHtml:function(a){// needed for matchCellWidths
return this.weekNumbersVisible?'<td class="fc-week-number" '+this.weekNumberStyleAttr()+"><span>"+this.calendar.calculateWeekNumber(this.cellToDate(a,0))+"</span></td>":void 0},
// Generates the HTML that goes before the day bg cells for each day-row.
// Queried by the DayGrid subcomponent. Ordering depends on isRTL.
dayIntroHtml:function(){return this.weekNumbersVisible?'<td class="fc-week-number '+this.widgetContentClass+'" '+this.weekNumberStyleAttr()+"></td>":void 0},
// Generates the HTML that goes before every other type of row generated by DayGrid. Ordering depends on isRTL.
// Affects helper-skeleton and highlight-skeleton rows.
introHtml:function(){return this.weekNumbersVisible?'<td class="fc-week-number" '+this.weekNumberStyleAttr()+"></td>":void 0},
// Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
// The number row will only exist if either day numbers or week numbers are turned on.
numberCellHtml:function(a,b,c){var d;return this.dayNumbersVisible?(d=this.dayGrid.getDayClasses(c),d.unshift("fc-day-number"),'<td class="'+d.join(" ")+'" data-date="'+c.format()+'">'+c.date()+"</td>"):"<td/>"},
// Generates an HTML attribute string for setting the width of the week number column, if it is known
weekNumberStyleAttr:function(){return null!==this.weekNumberWidth?'style="width:'+this.weekNumberWidth+'px"':""},
// Determines whether each row should have a constant height
hasRigidRows:function(){var a=this.opt("eventLimit");return a&&"number"!=typeof a},/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/
// Refreshes the horizontal dimensions of the view
updateWidth:function(){this.weekNumbersVisible&&(
// Make sure all week number cells running down the side have the same width.
// Record the width for cells created later.
this.weekNumberWidth=r(this.el.find(".fc-week-number")))},
// Adjusts the vertical dimensions of the view to the specified values
setHeight:function(a,b){var c,d=this.opt("eventLimit");
// reset all heights to be natural
t(this.scrollerEl),m(this.headRowEl),this.dayGrid.destroySegPopover(),// kill the "more" popover if displayed
// is the event limit a constant level number?
d&&"number"==typeof d&&this.dayGrid.limitRows(d),c=this.computeScrollerHeight(a),this.setGridHeight(c,b),d&&"number"!=typeof d&&this.dayGrid.limitRows(d),!b&&s(this.scrollerEl,c)&&(l(this.headRowEl,v(this.scrollerEl)),c=this.computeScrollerHeight(a),this.scrollerEl.height(c),this.restoreScroll())},
// Sets the height of just the DayGrid component in this view
setGridHeight:function(a,b){b?q(this.dayGrid.rowEls):p(this.dayGrid.rowEls,a,!0)},/* Events
	------------------------------------------------------------------------------------------------------------------*/
// Renders the given events onto the view and populates the segments array
renderEvents:function(a){this.dayGrid.renderEvents(a),this.updateHeight(),// must compensate for events that overflow the row
va.prototype.renderEvents.call(this,a)},
// Retrieves all segment objects that are rendered in the view
getSegs:function(){return this.dayGrid.getSegs()},
// Unrenders all event elements and clears internal segment data
destroyEvents:function(){va.prototype.destroyEvents.call(this),// do this before dayGrid's segs have been cleared
this.recordScroll(),// removing events will reduce height and mess with the scroll, so record beforehand
this.dayGrid.destroyEvents()},/* Event Dragging
	------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of an event being dragged over the view.
// A returned value of `true` signals that a mock "helper" event has been rendered.
renderDrag:function(a,b,c){return this.dayGrid.renderDrag(a,b,c)},
// Unrenders the visual indication of an event being dragged over the view
destroyDrag:function(){this.dayGrid.destroyDrag()},/* Selection
	------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of a selection
renderSelection:function(a,b){this.dayGrid.renderSelection(a,b)},
// Unrenders a visual indications of a selection
destroySelection:function(){this.dayGrid.destroySelection()}}),/* A month view with day cells running in rows (one-per-week) and columns
----------------------------------------------------------------------------------------------------------------------*/
e({fixedWeekCount:!0}),Ka.month=ya,ya.prototype=C(xa.prototype),// define the super-class
a.extend(ya.prototype,{name:"month",incrementDate:function(a,b){return a.clone().stripTime().add(b,"months").startOf("month")},render:function(a){var b;this.intervalStart=a.clone().stripTime().startOf("month"),this.intervalEnd=this.intervalStart.clone().add(1,"months"),this.start=this.intervalStart.clone(),this.start=this.skipHiddenDays(this.start),// move past the first week if no visible days
this.start.startOf("week"),this.start=this.skipHiddenDays(this.start),// move past the first invisible days of the week
this.end=this.intervalEnd.clone(),this.end=this.skipHiddenDays(this.end,-1,!0),// move in from the last week if no visible days
this.end.add((7-this.end.weekday())%7,"days"),// move to end of week if not already
this.end=this.skipHiddenDays(this.end,-1,!0),b=Math.ceil(// need to ceil in case there are hidden days
this.end.diff(this.start,"weeks",!0)),this.isFixedWeeks()&&(this.end.add(6-b,"weeks"),b=6),this.title=this.calendar.formatDate(this.intervalStart,this.opt("titleFormat")),xa.prototype.render.call(this,b,this.getCellsPerWeek(),!0)},
// Overrides the default BasicView behavior to have special multi-week auto-height logic
setGridHeight:function(a,b){b=b||"variable"===this.opt("weekMode"),b&&(a*=this.rowCnt/6),p(this.dayGrid.rowEls,a,!b)},isFixedWeeks:function(){var a=this.opt("weekMode");// LEGACY: weekMode is deprecated
// LEGACY: weekMode is deprecated
return a?"fixed"===a:this.opt("fixedWeekCount")}}),/* A week view with simple day cells running horizontally
----------------------------------------------------------------------------------------------------------------------*/
// TODO: a WeekView mixin for calculating dates and titles
Ka.basicWeek=za,za.prototype=C(xa.prototype),// define the super-class
a.extend(za.prototype,{name:"basicWeek",incrementDate:function(a,b){return a.clone().stripTime().add(b,"weeks").startOf("week")},render:function(a){this.intervalStart=a.clone().stripTime().startOf("week"),this.intervalEnd=this.intervalStart.clone().add(1,"weeks"),this.start=this.skipHiddenDays(this.intervalStart),this.end=this.skipHiddenDays(this.intervalEnd,-1,!0),this.title=this.calendar.formatRange(this.start,this.end.clone().subtract(1),// make inclusive by subtracting 1 ms
this.opt("titleFormat")," — "),xa.prototype.render.call(this,1,this.getCellsPerWeek(),!1)}}),/* A view with a single simple day cell
----------------------------------------------------------------------------------------------------------------------*/
Ka.basicDay=Aa,Aa.prototype=C(xa.prototype),// define the super-class
a.extend(Aa.prototype,{name:"basicDay",incrementDate:function(a,b){var c=a.clone().stripTime().add(b,"days");return c=this.skipHiddenDays(c,0>b?-1:1)},render:function(a){this.start=this.intervalStart=a.clone().stripTime(),this.end=this.intervalEnd=this.start.clone().add(1,"days"),this.title=this.calendar.formatDate(this.start,this.opt("titleFormat")),xa.prototype.render.call(this,1,1,!1)}}),/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
----------------------------------------------------------------------------------------------------------------------*/
// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.
e({allDaySlot:!0,allDayText:"all-day",scrollTime:"06:00:00",slotDuration:"00:30:00",axisFormat:Ba,timeFormat:{agenda:Ca},minTime:"00:00:00",maxTime:"24:00:00",slotEventOverlap:!0});var Ya=5;Da.prototype=C(va.prototype),// define the super-class
a.extend(Da.prototype,{timeGrid:null,// the main time-grid subcomponent of this view
dayGrid:null,// the "all-day" subcomponent. if all-day is turned off, this will be null
axisWidth:null,// the width of the time axis running down the side
noScrollRowEls:null,// set of fake row elements that must compensate when scrollerEl has scrollbars
// when the time-grid isn't tall enough to occupy the given height, we render an <hr> underneath
bottomRuleEl:null,bottomRuleHeight:null,/* Rendering
	------------------------------------------------------------------------------------------------------------------*/
// Renders the view into `this.el`, which has already been assigned.
// `colCnt` has been calculated by a subclass and passed here.
render:function(b){
// needed for cell-to-date and date-to-cell calculations in View
this.rowCnt=1,this.colCnt=b,this.el.addClass("fc-agenda-view").html(this.renderHtml()),
// the element that wraps the time-grid that will probably scroll
this.scrollerEl=this.el.find(".fc-time-grid-container"),this.timeGrid.coordMap.containerEl=this.scrollerEl,// don't accept clicks/etc outside of this
this.timeGrid.el=this.el.find(".fc-time-grid"),this.timeGrid.render(),
// the <hr> that sometimes displays under the time-grid
this.bottomRuleEl=a('<hr class="'+this.widgetHeaderClass+'"/>').appendTo(this.timeGrid.el),// inject it into the time-grid
this.dayGrid&&(this.dayGrid.el=this.el.find(".fc-day-grid"),this.dayGrid.render(),
// have the day-grid extend it's coordinate area over the <hr> dividing the two grids
this.dayGrid.bottomCoordPadding=this.dayGrid.el.next("hr").outerHeight()),this.noScrollRowEls=this.el.find(".fc-row:not(.fc-scroller *)"),// fake rows not within the scroller
va.prototype.render.call(this),// call the super-method
this.resetScroll()},
// Make subcomponents ready for cleanup
destroy:function(){this.timeGrid.destroy(),this.dayGrid&&this.dayGrid.destroy(),va.prototype.destroy.call(this)},
// Builds the HTML skeleton for the view.
// The day-grid and time-grid components will render inside containers defined by this HTML.
renderHtml:function(){// render the day-of-week headers
return'<table><thead><tr><td class="'+this.widgetHeaderClass+'">'+this.timeGrid.headHtml()+'</td></tr></thead><tbody><tr><td class="'+this.widgetContentClass+'">'+(this.dayGrid?'<div class="fc-day-grid"/><hr class="'+this.widgetHeaderClass+'"/>':"")+'<div class="fc-time-grid-container"><div class="fc-time-grid"/></div></td></tr></tbody></table>'},
// Generates the HTML that will go before the day-of week header cells.
// Queried by the TimeGrid subcomponent when generating rows. Ordering depends on isRTL.
headIntroHtml:function(){var a,b,c,d;// needed for matchCellWidths
return this.opt("weekNumbers")?(a=this.cellToDate(0,0),b=this.calendar.calculateWeekNumber(a),c=this.opt("weekNumberTitle"),d=this.opt("isRTL")?b+c:c+b,'<th class="fc-axis fc-week-number '+this.widgetHeaderClass+'" '+this.axisStyleAttr()+"><span>"+F(d)+"</span></th>"):'<th class="fc-axis '+this.widgetHeaderClass+'" '+this.axisStyleAttr()+"></th>"},
// Generates the HTML that goes before the all-day cells.
// Queried by the DayGrid subcomponent when generating rows. Ordering depends on isRTL.
dayIntroHtml:function(){// needed for matchCellWidths
return'<td class="fc-axis '+this.widgetContentClass+'" '+this.axisStyleAttr()+"><span>"+(this.opt("allDayHtml")||F(this.opt("allDayText")))+"</span></td>"},
// Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
slotBgIntroHtml:function(){return'<td class="fc-axis '+this.widgetContentClass+'" '+this.axisStyleAttr()+"></td>"},
// Generates the HTML that goes before all other types of cells.
// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
// Queried by the TimeGrid and DayGrid subcomponents when generating rows. Ordering depends on isRTL.
introHtml:function(){return'<td class="fc-axis" '+this.axisStyleAttr()+"></td>"},
// Generates an HTML attribute string for setting the width of the axis, if it is known
axisStyleAttr:function(){return null!==this.axisWidth?'style="width:'+this.axisWidth+'px"':""},/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/
updateSize:function(a){a&&this.timeGrid.resize(),va.prototype.updateSize.call(this,a)},
// Refreshes the horizontal dimensions of the view
updateWidth:function(){
// make all axis cells line up, and record the width so newly created axis cells will have it
this.axisWidth=r(this.el.find(".fc-axis"))},
// Adjusts the vertical dimensions of the view to the specified values
setHeight:function(a,b){var c,d;null===this.bottomRuleHeight&&(
// calculate the height of the rule the very first time
this.bottomRuleHeight=this.bottomRuleEl.outerHeight()),this.bottomRuleEl.hide(),// .show() will be called later if this <hr> is necessary
// reset all dimensions back to the original state
this.scrollerEl.css("overflow",""),t(this.scrollerEl),m(this.noScrollRowEls),
// limit number of events in the all-day area
this.dayGrid&&(this.dayGrid.destroySegPopover(),c=this.opt("eventLimit"),c&&"number"!=typeof c&&(c=Ya),c&&this.dayGrid.limitRows(c)),b||(d=this.computeScrollerHeight(a),s(this.scrollerEl,d)?(l(this.noScrollRowEls,v(this.scrollerEl)),d=this.computeScrollerHeight(a),this.scrollerEl.height(d),this.restoreScroll()):(this.scrollerEl.height(d).css("overflow","hidden"),this.bottomRuleEl.show()))},
// Sets the scroll value of the scroller to the intial pre-configured state prior to allowing the user to change it.
resetScroll:function(){function a(){c.scrollerEl.scrollTop(e)}var c=this,d=b.duration(this.opt("scrollTime")),e=this.timeGrid.computeTimeTop(d);e=Math.ceil(e),e&&e++,a(),setTimeout(a,0)},/* Events
	------------------------------------------------------------------------------------------------------------------*/
// Renders events onto the view and populates the View's segment array
renderEvents:function(a){var b,c,d=[],e=[],f=[];
// separate the events into all-day and timed
for(c=0;c<a.length;c++)a[c].allDay?d.push(a[c]):e.push(a[c]);b=this.timeGrid.renderEvents(e),this.dayGrid&&(f=this.dayGrid.renderEvents(d)),this.updateHeight(),va.prototype.renderEvents.call(this,a)},
// Retrieves all segment objects that are rendered in the view
getSegs:function(){return this.timeGrid.getSegs().concat(this.dayGrid?this.dayGrid.getSegs():[])},
// Unrenders all event elements and clears internal segment data
destroyEvents:function(){va.prototype.destroyEvents.call(this),// do this before the grids' segs have been cleared
// if destroyEvents is being called as part of an event rerender, renderEvents will be called shortly
// after, so remember what the scroll value was so we can restore it.
this.recordScroll(),
// destroy the events in the subcomponents
this.timeGrid.destroyEvents(),this.dayGrid&&this.dayGrid.destroyEvents()},/* Event Dragging
	------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of an event being dragged over the view.
// A returned value of `true` signals that a mock "helper" event has been rendered.
renderDrag:function(a,b,c){return a.hasTime()?this.timeGrid.renderDrag(a,b,c):this.dayGrid?this.dayGrid.renderDrag(a,b,c):void 0},
// Unrenders a visual indications of an event being dragged over the view
destroyDrag:function(){this.timeGrid.destroyDrag(),this.dayGrid&&this.dayGrid.destroyDrag()},/* Selection
	------------------------------------------------------------------------------------------------------------------*/
// Renders a visual indication of a selection
renderSelection:function(a,b){a.hasTime()||b.hasTime()?this.timeGrid.renderSelection(a,b):this.dayGrid&&this.dayGrid.renderSelection(a,b)},
// Unrenders a visual indications of a selection
destroySelection:function(){this.timeGrid.destroySelection(),this.dayGrid&&this.dayGrid.destroySelection()}}),/* A week view with an all-day cell area at the top, and a time grid below
----------------------------------------------------------------------------------------------------------------------*/
// TODO: a WeekView mixin for calculating dates and titles
Ka.agendaWeek=Ea,Ea.prototype=C(Da.prototype),// define the super-class
a.extend(Ea.prototype,{name:"agendaWeek",incrementDate:function(a,b){return a.clone().stripTime().add(b,"weeks").startOf("week")},render:function(a){this.intervalStart=a.clone().stripTime().startOf("week"),this.intervalEnd=this.intervalStart.clone().add(1,"weeks"),this.start=this.skipHiddenDays(this.intervalStart),this.end=this.skipHiddenDays(this.intervalEnd,-1,!0),this.title=this.calendar.formatRange(this.start,this.end.clone().subtract(1),// make inclusive by subtracting 1 ms
this.opt("titleFormat")," — "),Da.prototype.render.call(this,this.getCellsPerWeek())}}),/* A day view with an all-day cell area at the top, and a time grid below
----------------------------------------------------------------------------------------------------------------------*/
Ka.agendaDay=Fa,Fa.prototype=C(Da.prototype),// define the super-class
a.extend(Fa.prototype,{name:"agendaDay",incrementDate:function(a,b){var c=a.clone().stripTime().add(b,"days");return c=this.skipHiddenDays(c,0>b?-1:1)},render:function(a){this.start=this.intervalStart=a.clone().stripTime(),this.end=this.intervalEnd=this.start.clone().add(1,"days"),this.title=this.calendar.formatDate(this.start,this.opt("titleFormat")),Da.prototype.render.call(this,1)}})});